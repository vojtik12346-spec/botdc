#!/usr/bin/env python3
"""
Discord Countdown Bot
- OdpoÄet s ping notifikacÃ­
"""

import discord
from discord.ext import commands
from discord import app_commands
import asyncio
import re
import os
from datetime import datetime, timezone
from dotenv import load_dotenv
import uuid

load_dotenv()

# Bot setup
intents = discord.Intents.default()
intents.message_content = True

bot = commands.Bot(command_prefix='!', intents=intents)

# ============== COUNTDOWN FUNCTIONS ==============

def parse_time(time_str: str) -> int:
    """Parse time string like 2m, 5m, 1h into seconds"""
    time_str = time_str.lower().strip()
    
    pattern = r'^(\d+)([smhd])$'
    match = re.match(pattern, time_str)
    
    if not match:
        return None
    
    value = int(match.group(1))
    unit = match.group(2)
    
    multipliers = {
        's': 1,
        'm': 60,
        'h': 3600,
        'd': 86400
    }
    
    return value * multipliers[unit]

def format_time(seconds: int) -> str:
    """Format seconds into readable string"""
    if seconds <= 0:
        return "0s"
    
    days = seconds // 86400
    hours = (seconds % 86400) // 3600
    minutes = (seconds % 3600) // 60
    secs = seconds % 60
    
    parts = []
    if days > 0:
        parts.append(f"{days}d")
    if hours > 0:
        parts.append(f"{hours}h")
    if minutes > 0:
        parts.append(f"{minutes}m")
    if secs > 0 or not parts:
        parts.append(f"{secs}s")
    
    return " ".join(parts)

# Store active countdowns
active_countdowns = {}

class CountdownView(discord.ui.View):
    def __init__(self, countdown_id: str, user_id: int):
        super().__init__(timeout=None)
        self.countdown_id = countdown_id
        self.user_id = user_id
    
    @discord.ui.button(label="ZruÅ¡it", style=discord.ButtonStyle.danger, emoji="âŒ")
    async def cancel_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id and not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message("âŒ Pouze autor nebo admin mÅ¯Å¾e zruÅ¡it odpoÄet!", ephemeral=True)
            return
        
        if self.countdown_id in active_countdowns:
            active_countdowns[self.countdown_id]["cancelled"] = True
            del active_countdowns[self.countdown_id]
        
        button.disabled = True
        button.label = "ZruÅ¡eno"
        
        embed = discord.Embed(
            title="âŒ OdpoÄet zruÅ¡en!",
            description=f"OdpoÄet byl zruÅ¡en uÅ¾ivatelem {interaction.user.mention}",
            color=discord.Color.red()
        )
        
        await interaction.response.edit_message(embed=embed, view=self)
        self.stop()

async def run_countdown(channel, message, end_time: int, countdown_id: str, author: discord.Member, reason: str):
    """Run the countdown and update message"""
    
    while True:
        if countdown_id not in active_countdowns:
            return
        
        if active_countdowns[countdown_id].get("cancelled"):
            return
        
        remaining = end_time - int(datetime.now(timezone.utc).timestamp())
        
        if remaining <= 0:
            break
        
        embed = discord.Embed(
            title="â° ODPOÄŒET",
            description=f"**{reason}**" if reason else "OdpoÄet bÄ›Å¾Ã­...",
            color=discord.Color.blue()
        )
        embed.add_field(name="â³ ZbÃ½vÃ¡", value=f"**{format_time(remaining)}**", inline=True)
        embed.add_field(name="ğŸ‘¤ Spustil", value=author.mention, inline=True)
        embed.set_footer(text=f"KonÄÃ­: {datetime.fromtimestamp(end_time).strftime('%H:%M:%S')}")
        
        try:
            await message.edit(embed=embed)
        except:
            pass
        
        if remaining > 3600:
            await asyncio.sleep(60)
        elif remaining > 60:
            await asyncio.sleep(10)
        else:
            await asyncio.sleep(1)
    
    # Countdown finished!
    if countdown_id in active_countdowns:
        del active_countdowns[countdown_id]
    
    embed = discord.Embed(
        title="ğŸ‰ ODPOÄŒET SKONÄŒIL!",
        description=f"**{reason}**" if reason else "ÄŒas vyprÅ¡el!",
        color=discord.Color.green()
    )
    embed.add_field(name="ğŸ‘¤ Spustil", value=author.mention, inline=True)
    
    view = discord.ui.View()
    disabled_btn = discord.ui.Button(label="DokonÄeno", style=discord.ButtonStyle.success, disabled=True, emoji="âœ…")
    view.add_item(disabled_btn)
    
    try:
        await message.edit(embed=embed, view=view)
    except:
        pass
    
    # Ping notification
    await channel.send(f"ğŸ”” **ODPOÄŒET SKONÄŒIL!** {author.mention}\n{'ğŸ“¢ ' + reason if reason else ''}")

# ============== EVENTS ==============

@bot.event
async def on_ready():
    print(f'ğŸ¤– Bot {bot.user} je online!', flush=True)
    print(f'ğŸ“Š PÅ™ipojen k {len(bot.guilds)} serverÅ¯m', flush=True)
    try:
        synced = await bot.tree.sync()
        print(f'âœ… SynchronizovÃ¡no {len(synced)} slash pÅ™Ã­kazÅ¯', flush=True)
    except Exception as e:
        print(f'âŒ Chyba pÅ™i synchronizaci: {e}', flush=True)

# ============== COUNTDOWN COMMANDS ==============

@bot.tree.command(name="odpocet", description="SpusÅ¥ odpoÄet (napÅ™. 2m, 5m, 1h)")
@app_commands.describe(
    cas="ÄŒas odpoÄtu (napÅ™. 30s, 2m, 1h, 1d)",
    duvod="DÅ¯vod/popis odpoÄtu (volitelnÃ©)"
)
async def slash_odpocet(interaction: discord.Interaction, cas: str, duvod: str = None):
    seconds = parse_time(cas)
    
    if seconds is None:
        await interaction.response.send_message(
            "âŒ NeplatnÃ½ formÃ¡t Äasu! PouÅ¾ij napÅ™. `30s`, `2m`, `1h`, `1d`",
            ephemeral=True
        )
        return
    
    if seconds < 5:
        await interaction.response.send_message("âŒ MinimÃ¡lnÃ­ Äas je 5 sekund!", ephemeral=True)
        return
    
    if seconds > 86400 * 7:
        await interaction.response.send_message("âŒ MaximÃ¡lnÃ­ Äas je 7 dnÃ­!", ephemeral=True)
        return
    
    countdown_id = str(uuid.uuid4())
    end_time = int(datetime.now(timezone.utc).timestamp()) + seconds
    
    embed = discord.Embed(
        title="â° ODPOÄŒET",
        description=f"**{duvod}**" if duvod else "OdpoÄet bÄ›Å¾Ã­...",
        color=discord.Color.blue()
    )
    embed.add_field(name="â³ ZbÃ½vÃ¡", value=f"**{format_time(seconds)}**", inline=True)
    embed.add_field(name="ğŸ‘¤ Spustil", value=interaction.user.mention, inline=True)
    embed.set_footer(text=f"KonÄÃ­: {datetime.fromtimestamp(end_time).strftime('%H:%M:%S')}")
    
    view = CountdownView(countdown_id, interaction.user.id)
    
    await interaction.response.send_message(embed=embed, view=view)
    message = await interaction.original_response()
    
    active_countdowns[countdown_id] = {"cancelled": False}
    
    asyncio.create_task(run_countdown(
        interaction.channel,
        message,
        end_time,
        countdown_id,
        interaction.user,
        duvod
    ))

@bot.command(name="odpocet", aliases=["countdown", "timer"])
async def prefix_odpocet(ctx, cas: str, *, duvod: str = None):
    """!odpocet 2m [dÅ¯vod] - SpusÅ¥ odpoÄet"""
    seconds = parse_time(cas)
    
    if seconds is None:
        await ctx.send("âŒ NeplatnÃ½ formÃ¡t Äasu! PouÅ¾ij napÅ™. `30s`, `2m`, `1h`, `1d`")
        return
    
    if seconds < 5:
        await ctx.send("âŒ MinimÃ¡lnÃ­ Äas je 5 sekund!")
        return
    
    if seconds > 86400 * 7:
        await ctx.send("âŒ MaximÃ¡lnÃ­ Äas je 7 dnÃ­!")
        return
    
    countdown_id = str(uuid.uuid4())
    end_time = int(datetime.now(timezone.utc).timestamp()) + seconds
    
    embed = discord.Embed(
        title="â° ODPOÄŒET",
        description=f"**{duvod}**" if duvod else "OdpoÄet bÄ›Å¾Ã­...",
        color=discord.Color.blue()
    )
    embed.add_field(name="â³ ZbÃ½vÃ¡", value=f"**{format_time(seconds)}**", inline=True)
    embed.add_field(name="ğŸ‘¤ Spustil", value=ctx.author.mention, inline=True)
    embed.set_footer(text=f"KonÄÃ­: {datetime.fromtimestamp(end_time).strftime('%H:%M:%S')}")
    
    view = CountdownView(countdown_id, ctx.author.id)
    
    message = await ctx.send(embed=embed, view=view)
    
    active_countdowns[countdown_id] = {"cancelled": False}
    
    asyncio.create_task(run_countdown(
        ctx.channel,
        message,
        end_time,
        countdown_id,
        ctx.author,
        duvod
    ))

@bot.tree.command(name="help", description="Zobraz nÃ¡povÄ›du")
async def slash_help(interaction: discord.Interaction):
    embed = discord.Embed(
        title="â° Countdown Bot",
        description="PÅ™Ã­kazy pro odpoÄet:",
        color=discord.Color.blue()
    )
    embed.add_field(
        name="PouÅ¾itÃ­",
        value="""
`/odpocet [Äas] [dÅ¯vod]` - SpusÅ¥ odpoÄet
`!odpocet [Äas] [dÅ¯vod]` - Prefix verze
        """,
        inline=False
    )
    embed.add_field(
        name="FormÃ¡ty Äasu",
        value="""
`30s` - 30 sekund
`2m` - 2 minuty
`1h` - 1 hodina
`1d` - 1 den
        """,
        inline=False
    )
    embed.add_field(
        name="PÅ™Ã­klady",
        value="""
`/odpocet 5m`
`/odpocet 1h SoutÄ›Å¾ zaÄÃ­nÃ¡!`
`!odpocet 30s RychlÃ½ odpoÄet`
        """,
        inline=False
    )
    await interaction.response.send_message(embed=embed)

@bot.command(name="pomoc")
async def prefix_help(ctx):
    """!pomoc - Zobraz nÃ¡povÄ›du"""
    embed = discord.Embed(
        title="â° Countdown Bot",
        description="PÅ™Ã­kazy pro odpoÄet:",
        color=discord.Color.blue()
    )
    embed.add_field(
        name="PouÅ¾itÃ­",
        value="`!odpocet [Äas] [dÅ¯vod]`",
        inline=False
    )
    embed.add_field(
        name="FormÃ¡ty",
        value="`30s`, `2m`, `1h`, `1d`",
        inline=False
    )
    await ctx.send(embed=embed)

# ============== RUN BOT ==============

if __name__ == "__main__":
    import sys
    sys.stdout.reconfigure(line_buffering=True)
    sys.stderr.reconfigure(line_buffering=True)
    
    token = os.environ.get('DISCORD_BOT_TOKEN')
    if not token:
        print("âŒ DISCORD_BOT_TOKEN nenÃ­ nastaven!", flush=True)
        exit(1)
    
    print("ğŸš€ SpouÅ¡tÃ­m Countdown Bot...", flush=True)
    bot.run(token)
