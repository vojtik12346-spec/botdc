_progress:,}/{xp_needed:,} XP)", value=f"`{progress_bar}`", inline=False)
    
    # KvÃ­zovÃ© statistiky
    embed.add_field(name="ğŸ® KvÃ­zÅ¯", value=f"**{user_data.get('total_games', 0)}**", inline=True)
    embed.add_field(name="âœ… SprÃ¡vnÄ›", value=f"**{user_data.get('total_correct', 0)}**", inline=True)
    embed.add_field(name="ğŸ¯ PÅ™esnost", value=f"**{accuracy:.1f}%**", inline=True)
    
    # HernÃ­ statistiky
    embed.add_field(name="ğŸ•¹ï¸ OdemÄenÃ© hry", value=f"**{len(unlocked_games)}** her", inline=True)
    embed.add_field(name="â±ï¸ ÄŒas hranÃ­", value=f"**{time_str}**", inline=True)
    embed.add_field(name="ğŸ“… DennÃ­ XP", value=f"**{user_data.get('daily_game_xp', 0)}/{DAILY_XP_LIMIT}**", inline=True)
    
    # Top 3 nejhranÄ›jÅ¡Ã­ hry
    if game_times:
        sorted_games = sorted(game_times.items(), key=lambda x: x[1], reverse=True)[:3]
        top_games = []
        for game, mins in sorted_games:
            g_hours = mins // 60
            g_mins = mins % 60
            g_time = f"{g_hours}h {g_mins}m" if g_hours > 0 else f"{g_mins}m"
            top_games.append(f"â€¢ **{game}**: {g_time}")
        
        if top_games:
            embed.add_field(name="ğŸ® NejhranÄ›jÅ¡Ã­ hry", value="\n".join(top_games), inline=False)
    
    embed.set_footer(text="âš”ï¸ Valhalla Bot â€¢ /hry pro vÅ¡echny hry â€¢ /ukoly pro Ãºkoly")
    
    msg = await ctx.send(embed=embed)
    asyncio.create_task(delete_after(msg, 60))

@bot.tree.command(name="top", description="Zobraz Å¾ebÅ™Ã­Äek hrÃ¡ÄÅ¯")
async def slash_top(interaction: discord.Interaction):
    # Check permission from database
    if not await check_command_permission(interaction, "top"):
        return
    
    # Get top 10 users for this guild
    top_users = list(users_collection.find(
        {"guild_id": interaction.guild_id}
    ).sort("xp", -1).limit(10))
    
    if not top_users:
        await interaction.response.send_message("ğŸ“Š ZatÃ­m nikdo nehrÃ¡l! ZaÄni s `/hudba` nebo `/film`", ephemeral=True)
        return
    
    embed = discord.Embed(
        title="ğŸ† TOP HRÃÄŒI",
        color=discord.Color.gold()
    )
    
    medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
    leaderboard = []
    
    for i, user in enumerate(top_users):
        level = calculate_level(user["xp"])
        badge = get_badge(level)
        medal = medals[i] if i < 3 else f"`{i+1}.`"
        name = user.get("name", f"HrÃ¡Ä {user['user_id']}")
        leaderboard.append(f"{medal} {badge} **{name}** â€¢ Level {level} â€¢ {user['xp']} XP")
    
    embed.description = "\n".join(leaderboard)
    embed.set_footer(text="âš”ï¸ Valhalla Bot â€¢ ZÃ­skej XP hranÃ­m kvÃ­zÅ¯!")
    
    await interaction.response.send_message(embed=embed)
    msg = await interaction.original_response()
    asyncio.create_task(delete_after(msg, 60))

@bot.command(name="top", aliases=["leaderboard", "lb", "zebricek"])
async def prefix_top(ctx):
    """!top - Zobraz Å¾ebÅ™Ã­Äek"""
    top_users = list(users_collection.find(
        {"guild_id": ctx.guild.id}
    ).sort("xp", -1).limit(10))
    
    if not top_users:
        msg = await ctx.send("ğŸ“Š ZatÃ­m nikdo nehrÃ¡l! ZaÄni s `!hudba` nebo `!film`")
        asyncio.create_task(delete_after(msg, 60))
        return
    
    embed = discord.Embed(title="ğŸ† TOP HRÃÄŒI", color=discord.Color.gold())
    
    medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
    leaderboard = []
    
    for i, user in enumerate(top_users):
        level = calculate_level(user["xp"])
        badge = get_badge(level)
        medal = medals[i] if i < 3 else f"`{i+1}.`"
        name = user.get("name", f"HrÃ¡Ä {user['user_id']}")
        leaderboard.append(f"{medal} {badge} **{name}** â€¢ Level {level} â€¢ {user['xp']} XP")
    
    embed.description = "\n".join(leaderboard)
    msg = await ctx.send(embed=embed)
    asyncio.create_task(delete_after(msg, 60))

@bot.tree.command(name="daily", description="ZÃ­skej dennÃ­ bonus XP!")
async def slash_daily(interaction: discord.Interaction):
    # Check permission from database
    if not await check_command_permission(interaction, "daily"):
        return
    
    guild_id = interaction.guild_id
    user_id = interaction.user.id
    user_data = get_user_data(guild_id, user_id)
    
    now = datetime.now(timezone.utc)
    last_daily = user_data.get("last_daily")
    
    if last_daily:
        if isinstance(last_daily, str):
            last_daily = datetime.fromisoformat(last_daily.replace('Z', '+00:00'))
        
        time_diff = now - last_daily
        if time_diff.total_seconds() < 86400:  # 24 hours
            remaining = 86400 - time_diff.total_seconds()
            hours = int(remaining // 3600)
            minutes = int((remaining % 3600) // 60)
            await interaction.response.send_message(
                f"â° DennÃ­ bonus uÅ¾ jsi dnes vybral/a!\nDalÅ¡Ã­ za **{hours}h {minutes}m**",
                ephemeral=True
            )
            return
        
        # Check streak
        if time_diff.total_seconds() < 172800:  # 48 hours - streak continues
            new_streak = user_data.get("streak", 0) + 1
        else:
            new_streak = 1  # Streak reset
    else:
        new_streak = 1
    
    # Calculate bonus
    base_xp = XP_REWARDS["daily"]
    streak_bonus = min(new_streak - 1, 10) * XP_REWARDS["streak_bonus"]  # Max 10 days bonus
    total_xp = base_xp + streak_bonus
    
    # Update user
    users_collection.update_one(
        {"guild_id": guild_id, "user_id": user_id},
        {
            "$set": {"last_daily": now, "streak": new_streak},
            "$inc": {"xp": total_xp}
        }
    )
    
    new_xp = user_data["xp"] + total_xp
    new_level = calculate_level(new_xp)
    old_level = calculate_level(user_data["xp"])
    
    embed = discord.Embed(
        title="ğŸ DENNÃ BONUS!",
        color=discord.Color.green()
    )
    embed.add_field(name="âœ¨ ZÃ­skÃ¡no", value=f"+**{total_xp}** XP", inline=True)
    embed.add_field(name="ğŸ”¥ Streak", value=f"**{new_streak}** dnÅ¯", inline=True)
    
    if streak_bonus > 0:
        embed.add_field(name="ğŸ’« Streak bonus", value=f"+{streak_bonus} XP", inline=True)
    
    embed.set_footer(text="VraÅ¥ se zÃ­tra pro dalÅ¡Ã­ bonus!")
    
    await interaction.response.send_message(embed=embed)
    msg = await interaction.original_response()
    asyncio.create_task(delete_after(msg, 60))
    
    # Level up check
    if new_level > old_level:
        badge = get_badge(new_level)
        level_embed = discord.Embed(
            title="ğŸ‰ LEVEL UP!",
            description=f"**{interaction.user.display_name}** dosÃ¡hl/a **Level {new_level}** {badge}!",
            color=discord.Color.gold()
        )
        await interaction.channel.send(embed=level_embed)

@bot.command(name="daily", aliases=["denni", "bonus"])
async def prefix_daily(ctx):
    """!daily - ZÃ­skej dennÃ­ bonus"""
    guild_id = ctx.guild.id
    user_id = ctx.author.id
    user_data = get_user_data(guild_id, user_id)
    
    now = datetime.now(timezone.utc)
    last_daily = user_data.get("last_daily")
    
    if last_daily:
        if isinstance(last_daily, str):
            last_daily = datetime.fromisoformat(last_daily.replace('Z', '+00:00'))
        
        time_diff = now - last_daily
        if time_diff.total_seconds() < 86400:
            remaining = 86400 - time_diff.total_seconds()
            hours = int(remaining // 3600)
            minutes = int((remaining % 3600) // 60)
            await ctx.send(f"â° DennÃ­ bonus uÅ¾ jsi dnes vybral/a! DalÅ¡Ã­ za **{hours}h {minutes}m**")
            return
        
        if time_diff.total_seconds() < 172800:
            new_streak = user_data.get("streak", 0) + 1
        else:
            new_streak = 1
    else:
        new_streak = 1
    
    base_xp = XP_REWARDS["daily"]
    streak_bonus = min(new_streak - 1, 10) * XP_REWARDS["streak_bonus"]
    total_xp = base_xp + streak_bonus
    
    users_collection.update_one(
        {"guild_id": guild_id, "user_id": user_id},
        {
            "$set": {"last_daily": now, "streak": new_streak},
            "$inc": {"xp": total_xp}
        }
    )
    
    embed = discord.Embed(title="ğŸ DENNÃ BONUS!", color=discord.Color.green())
    embed.add_field(name="âœ¨ ZÃ­skÃ¡no", value=f"+**{total_xp}** XP", inline=True)
    embed.add_field(name="ğŸ”¥ Streak", value=f"**{new_streak}** dnÅ¯", inline=True)
    if streak_bonus > 0:
        embed.add_field(name="ğŸ’« Streak bonus", value=f"+{streak_bonus} XP", inline=True)
    embed.set_footer(text="VraÅ¥ se zÃ­tra pro dalÅ¡Ã­ bonus!")
    
    msg = await ctx.send(embed=embed)
    asyncio.create_task(delete_after(msg, 60))

# ============== GAME TRACKING ==============

@bot.event
async def on_presence_update(before: discord.Member, after: discord.Member):
    """Track when users start/stop playing games"""
    
    # Get the game activity
    before_game = None
    after_game = None
    
    for activity in before.activities:
        if activity.type == discord.ActivityType.playing:
            before_game = activity.name
            break
    
    for activity in after.activities:
        if activity.type == discord.ActivityType.playing:
            after_game = activity.name
            break
    
    # Skip if no change
    if before_game == after_game:
        return
    
    print(f"[GAME] {after.display_name}: '{before_game}' -> '{after_game}'", flush=True)
    
    user_id = after.id
    guild_id = after.guild.id
    
    # Started playing a game
    if after_game and not before_game:
        print(f"[GAME] â–¶ï¸ {after.display_name} zaÄal hrÃ¡t: {after_game}", flush=True)
        
        # UloÅ¾ do pamÄ›ti i databÃ¡ze
        active_gaming_sessions[user_id] = {
            "game": after_game,
            "start": datetime.now(timezone.utc),
            "guild_id": guild_id,
            "user_name": after.display_name
        }
        save_game_session(user_id, guild_id, after_game, after.display_name)
        
        # Get notification channel - VÅ½DY do sprÃ¡vnÃ©ho kanÃ¡lu
        channel = bot.get_channel(GAME_NOTIFICATION_CHANNEL)
        
        # Check if it's a bonus game to unlock
        if after_game in BONUS_GAMES:
            await unlock_game(guild_id, user_id, after.display_name, after_game, channel)
    
    # Stopped playing a game
    elif before_game and not after_game:
        # Zkus naÄÃ­st session z pamÄ›ti nebo databÃ¡ze
        session = active_gaming_sessions.get(user_id) or get_game_session(user_id)
        
        if session:
            start_time = session["start"]
            if isinstance(start_time, str):
                start_time = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
            minutes_played = int((datetime.now(timezone.utc) - start_time).total_seconds() / 60)
            
            print(f"[GAME] â¹ï¸ {session['user_name']} skonÄil hrÃ¡t: {session['game']} ({minutes_played} min)", flush=True)
            
            if minutes_played >= 10:
                # Get notification channel - VÅ½DY do sprÃ¡vnÃ©ho kanÃ¡lu
                channel = bot.get_channel(GAME_NOTIFICATION_CHANNEL)
                
                xp_earned = await add_game_xp(
                    session["guild_id"],
                    user_id,
                    session["user_name"],
                    minutes_played,
                    session["game"],
                    channel
                )
                
                if xp_earned > 0 and channel:
                    embed = discord.Embed(
                        title="ğŸ® XP za hranÃ­!",
                        description=f"**{session['user_name']}** hrÃ¡l/a **{session['game']}**",
                        color=discord.Color.blue()
                    )
                    embed.add_field(name="â±ï¸ ÄŒas", value=f"{minutes_played} min", inline=True)
                    embed.add_field(name="âœ¨ XP", value=f"+{xp_earned} XP", inline=True)
                    
                    daily_xp = get_daily_game_xp(guild_id, user_id)
                    embed.add_field(name="ğŸ“Š DennÃ­ limit", value=f"{daily_xp}/{GAME_XP_DAILY_LIMIT}", inline=True)
                    embed.set_footer(text="Hraj hry a zÃ­skÃ¡vej XP!")
                    await channel.send(embed=embed)
            
            # SmaÅ¾ z pamÄ›ti i databÃ¡ze
            if user_id in active_gaming_sessions:
                del active_gaming_sessions[user_id]
            delete_game_session(user_id)
    
    # Changed game
    elif before_game and after_game and before_game != after_game:
        # End previous session - zkus z pamÄ›ti nebo databÃ¡ze
        session = active_gaming_sessions.get(user_id) or get_game_session(user_id)
        
        if session:
            start_time = session["start"]
            if isinstance(start_time, str):
                start_time = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
            minutes_played = int((datetime.now(timezone.utc) - start_time).total_seconds() / 60)
            
            if minutes_played >= 10:
                await add_game_xp(guild_id, user_id, after.display_name, minutes_played, session["game"], None)
        
        # Start new session - uloÅ¾ do pamÄ›ti i databÃ¡ze
        active_gaming_sessions[user_id] = {
            "game": after_game,
            "start": datetime.now(timezone.utc),
            "guild_id": guild_id,
            "user_name": after.display_name
        }
        save_game_session(user_id, guild_id, after_game, after.display_name)
        
        # Check if new game is bonus game
        if after_game in BONUS_GAMES:
            channel = after.guild.system_channel
            if not channel:
                for ch in after.guild.text_channels:
                    if ch.permissions_for(after.guild.me).send_messages:
                        channel = ch
                        break
            await unlock_game(guild_id, user_id, after.display_name, after_game, channel)

@bot.tree.command(name="hry", description="Zobraz svÃ© odemÄenÃ© hry a achievementy")
async def slash_hry(interaction: discord.Interaction, hrac: discord.Member = None):
    # Check permission from database
    if not await check_command_permission(interaction, "hry"):
        return
    
    target = hrac or interaction.user
    user_data = get_user_data(interaction.guild_id, target.id)
    
    unlocked = user_data.get("unlocked_games", [])
    total_time = user_data.get("total_game_time", 0)
    daily_xp = get_daily_game_xp(interaction.guild_id, target.id)
    
    embed = discord.Embed(
        title=f"ğŸ® HernÃ­ profil - {target.display_name}",
        color=discord.Color.purple()
    )
    embed.set_thumbnail(url=target.display_avatar.url)
    
    embed.add_field(name="â±ï¸ CelkovÃ½ Äas hranÃ­", value=f"{total_time // 60}h {total_time % 60}m", inline=True)
    embed.add_field(name="ğŸ“Š DneÅ¡nÃ­ XP za hry", value=f"{daily_xp}/{GAME_XP_DAILY_LIMIT}", inline=True)
    embed.add_field(name="ğŸ† OdemÄeno her", value=f"{len(unlocked)}/{len(BONUS_GAMES)}", inline=True)
    
    # Show unlocked games
    if unlocked:
        game_list = []
        for game in unlocked[:15]:  # Max 15
            if game in BONUS_GAMES:
                emoji = BONUS_GAMES[game]["emoji"]
                game_list.append(f"{emoji} {game}")
            else:
                game_list.append(f"ğŸ® {game}")
        
        embed.add_field(
            name="âœ… OdemÄenÃ© hry",
            value="\n".join(game_list) if game_list else "Å½Ã¡dnÃ©",
            inline=False
        )
        
        if len(unlocked) > 15:
            embed.add_field(name="", value=f"... a {len(unlocked) - 15} dalÅ¡Ã­ch", inline=False)
    else:
        embed.add_field(name="âœ… OdemÄenÃ© hry", value="ZatÃ­m Å¾Ã¡dnÃ©. ZaÄni hrÃ¡t!", inline=False)
    
    # Show some locked games as hints
    locked = [g for g in list(BONUS_GAMES.keys())[:10] if g not in unlocked]
    if locked:
        hints = [f"ğŸ”’ {g}" for g in locked[:5]]
        embed.add_field(name="ğŸ”’ K odemÄenÃ­", value="\n".join(hints), inline=False)
    
    embed.set_footer(text=f"Hraj hry a zÃ­skÃ¡vej +{GAME_XP_PER_10_MIN} XP za 10 min â€¢ Max {GAME_XP_DAILY_LIMIT} XP/den")
    
    await interaction.response.send_message(embed=embed)
    msg = await interaction.original_response()
    asyncio.create_task(delete_after(msg, 60))

@bot.command(name="hry", aliases=["games", "achievements"])
async def prefix_hry(ctx, hrac: discord.Member = None):
    """!hry - Zobraz odemÄenÃ© hry"""
    target = hrac or ctx.author
    user_data = get_user_data(ctx.guild.id, target.id)
    
    unlocked = user_data.get("unlocked_games", [])
    total_time = user_data.get("total_game_time", 0)
    daily_xp = get_daily_game_xp(ctx.guild.id, target.id)
    
    embed = discord.Embed(
        title=f"ğŸ® HernÃ­ profil - {target.display_name}",
        color=discord.Color.purple()
    )
    embed.set_thumbnail(url=target.display_avatar.url)
    embed.add_field(name="â±ï¸ CelkovÃ½ Äas", value=f"{total_time // 60}h {total_time % 60}m", inline=True)
    embed.add_field(name="ğŸ“Š DneÅ¡nÃ­ XP", value=f"{daily_xp}/{GAME_XP_DAILY_LIMIT}", inline=True)
    embed.add_field(name="ğŸ† OdemÄeno", value=f"{len(unlocked)}/{len(BONUS_GAMES)}", inline=True)
    
    if unlocked:
        game_list = []
        for game in unlocked[:10]:
            emoji = BONUS_GAMES.get(game, {}).get("emoji", "ğŸ®")
            game_list.append(f"{emoji} {game}")
        embed.add_field(name="âœ… OdemÄenÃ© hry", value="\n".join(game_list), inline=False)
    else:
        embed.add_field(name="âœ… OdemÄenÃ© hry", value="ZatÃ­m Å¾Ã¡dnÃ©", inline=False)
    
    embed.set_footer(text=f"+{GAME_XP_PER_10_MIN} XP / 10 min â€¢ Max {GAME_XP_DAILY_LIMIT} XP/den")
    msg = await ctx.send(embed=embed)
    asyncio.create_task(delete_after(msg, 60))

@bot.tree.command(name="ukoly", description="Zobraz Ãºkoly pro konkrÃ©tnÃ­ hru")
@app_commands.describe(hra="Vyber hru pro zobrazenÃ­ ÃºkolÅ¯")
@app_commands.choices(hra=[
    app_commands.Choice(name="ğŸ¯ Counter-Strike 2", value="Counter-Strike 2"),
    app_commands.Choice(name="â›ï¸ Minecraft", value="Minecraft"),
    app_commands.Choice(name="âš”ï¸ League of Legends", value="League of Legends"),
    app_commands.Choice(name="ğŸï¸ Fortnite", value="Fortnite"),
    app_commands.Choice(name="ğŸ”« VALORANT", value="VALORANT"),
    app_commands.Choice(name="ğŸš” GTA V", value="GTA V"),
    app_commands.Choice(name="ğŸš— Rocket League", value="Rocket League"),
])
async def slash_ukoly(interaction: discord.Interaction, hra: str):
    # Check permission from database
    if not await check_command_permission(interaction, "ukoly"):
        return
    
    user_data = get_user_data(interaction.guild_id, interaction.user.id)
    game_time = user_data.get("game_times", {}).get(hra, 0)
    completed = user_data.get("completed_quests", {}).get(hra, [])
    quests = get_game_quests(hra)
    
    game_emoji = BONUS_GAMES.get(hra, {}).get("emoji", "ğŸ®")
    
    embed = discord.Embed(
        title=f"{game_emoji} Ãškoly - {hra}",
        description=f"TvÅ¯j Äas: **{game_time // 60}h {game_time % 60}m**",
        color=discord.Color.purple()
    )
    
    quest_list = []
    total_xp = 0
    earned_xp = 0
    
    for i, quest in enumerate(quests):
        total_xp += quest["xp"]
        hours = quest["minutes"] // 60
        mins = quest["minutes"] % 60
        time_str = f"{hours}h" if hours > 0 else f"{mins}m"
        if hours > 0 and mins > 0:
            time_str = f"{hours}h {mins}m"
        
        if i in completed:
            quest_list.append(f"âœ… {quest['emoji']} **{quest['name']}** - {time_str} (+{quest['xp']} XP)")
            earned_xp += quest["xp"]
        elif game_time >= quest["minutes"]:
            # Ready to claim (should auto-complete, but just in case)
            quest_list.append(f"ğŸ {quest['emoji']} **{quest['name']}** - {time_str} (+{quest['xp']} XP)")
        else:
            progress = min(100, (game_time / quest["minutes"]) * 100)
            quest_list.append(f"ğŸ”’ {quest['emoji']} {quest['name']} - {time_str} (+{quest['xp']} XP) [{progress:.0f}%]")
    
    embed.add_field(name="ğŸ“‹ Ãškoly", value="\n".join(quest_list), inline=False)
    embed.add_field(name="ğŸ’° ZÃ­skÃ¡no XP", value=f"{earned_xp}/{total_xp} XP", inline=True)
    embed.add_field(name="âœ… SplnÄ›no", value=f"{len(completed)}/{len(quests)}", inline=True)
    
    embed.set_footer(text="Hraj hru a Ãºkoly se automaticky splnÃ­!")
    
    await interaction.response.send_message(embed=embed)
    msg = await interaction.original_response()
    asyncio.create_task(delete_after(msg, 60))

@bot.command(name="ukoly", aliases=["quests", "mise", "tasks"])
async def prefix_ukoly(ctx, *, hra: str = None):
    """!ukoly [hra] - Zobraz Ãºkoly pro hru"""
    if not hra:
        # Show available games
        embed = discord.Embed(
            title="ğŸ¯ HernÃ­ Ãºkoly",
            description="Vyber hru pro zobrazenÃ­ ÃºkolÅ¯:",
            color=discord.Color.purple()
        )
        games_with_quests = list(GAME_QUESTS.keys())
        games_with_quests.remove("default")
        
        game_list = []
        for game in games_with_quests:
            emoji = BONUS_GAMES.get(game, {}).get("emoji", "ğŸ®")
            game_list.append(f"{emoji} `!ukoly {game}`")
        
        embed.add_field(name="DostupnÃ© hry", value="\n".join(game_list), inline=False)
        embed.set_footer(text="Nebo hraj jakoukoli hru - budeÅ¡ mÃ­t zÃ¡kladnÃ­ Ãºkoly!")
        msg = await ctx.send(embed=embed)
        asyncio.create_task(delete_after(msg, 60))
        return
    
    # Find matching game
    game_name = None
    for name in GAME_QUESTS.keys():
        if name.lower() == hra.lower() or hra.lower() in name.lower():
            game_name = name
            break
    
    if not game_name or game_name == "default":
        # Use the input as game name with default quests
        game_name = hra
    
    user_data = get_user_data(ctx.guild.id, ctx.author.id)
    game_time = user_data.get("game_times", {}).get(game_name, 0)
    completed = user_data.get("completed_quests", {}).get(game_name, [])
    quests = get_game_quests(game_name)
    
    game_emoji = BONUS_GAMES.get(game_name, {}).get("emoji", "ğŸ®")
    
    embed = discord.Embed(
        title=f"{game_emoji} Ãškoly - {game_name}",
        description=f"TvÅ¯j Äas: **{game_time // 60}h {game_time % 60}m**",
        color=discord.Color.purple()
    )
    
    quest_list = []
    total_xp = 0
    earned_xp = 0
    
    for i, quest in enumerate(quests):
        total_xp += quest["xp"]
        hours = quest["minutes"] // 60
        mins = quest["minutes"] % 60
        time_str = f"{hours}h" if hours > 0 else f"{mins}m"
        
        if i in completed:
            quest_list.append(f"âœ… {quest['emoji']} **{quest['name']}** (+{quest['xp']} XP)")
            earned_xp += quest["xp"]
        else:
            progress = min(100, (game_time / quest["minutes"]) * 100) if quest["minutes"] > 0 else 0
            quest_list.append(f"ğŸ”’ {quest['emoji']} {quest['name']} - {time_str} [{progress:.0f}%]")
    
    embed.add_field(name="ğŸ“‹ Ãškoly", value="\n".join(quest_list), inline=False)
    embed.add_field(name="ğŸ’° XP", value=f"{earned_xp}/{total_xp}", inline=True)
    embed.add_field(name="âœ… SplnÄ›no", value=f"{len(completed)}/{len(quests)}", inline=True)
    
    msg = await ctx.send(embed=embed)
    asyncio.create_task(delete_after(msg, 60))

# ============== POLL SYSTEM ==============

NUMBER_EMOJIS = ["1ï¸âƒ£", "2ï¸âƒ£", "3ï¸âƒ£", "4ï¸âƒ£", "5ï¸âƒ£", "6ï¸âƒ£", "7ï¸âƒ£", "8ï¸âƒ£", "9ï¸âƒ£", "ğŸ”Ÿ"]

# Store active polls: {poll_id: {votes: {user_id: option_index}, names: {user_id: name}, ...}}
active_polls = {}

class PollView(discord.ui.View):
    def __init__(self, poll_id: str, options: list, author_id: int, end_time: int):
        super().__init__(timeout=None)
        self.poll_id = poll_id
        self.options = options
        self.author_id = author_id
        self.end_time = end_time
        
        # Add buttons for each option
        for i, option in enumerate(options):
            button = discord.ui.Button(
                label=option[:50],  # Limit label length
                style=discord.ButtonStyle.secondary,
                emoji=NUMBER_EMOJIS[i],
                custom_id=f"poll_{poll_id}_{i}"
            )
            button.callback = self.make_vote_callback(i)
            self.add_item(button)
    
    def make_vote_callback(self, option_index: int):
        async def callback(interaction: discord.Interaction):
            poll_data = active_polls.get(self.poll_id)
            if not poll_data:
                await interaction.response.send_message("âŒ Tato anketa jiÅ¾ skonÄila!", ephemeral=True)
                return
            
            user_id = interaction.user.id
            user_name = interaction.user.display_name  # Get display name directly
            
            # Check if user already voted
            if user_id in poll_data["votes"]:
                previous_vote = poll_data["votes"][user_id]
                if previous_vote == option_index:
                    await interaction.response.send_message(
                        f"âŒ JiÅ¾ jsi hlasoval pro **{self.options[option_index]}**!",
                        ephemeral=True
                    )
                    return
                else:
                    # Change vote
                    poll_data["votes"][user_id] = option_index
                    poll_data["names"][user_id] = user_name  # Update name
                    await interaction.response.send_message(
                        f"ğŸ”„ ZmÄ›nil jsi hlas na **{self.options[option_index]}**!",
                        ephemeral=True
                    )
            else:
                # New vote
                poll_data["votes"][user_id] = option_index
                poll_data["names"][user_id] = user_name  # Store name
                await interaction.response.send_message(
                    f"âœ… Hlasoval jsi pro **{self.options[option_index]}**!",
                    ephemeral=True
                )
        
        return callback

def get_poll_results(poll_id: str, options: list, guild) -> str:
    """Generate poll results text with voter names"""
    poll_data = active_polls.get(poll_id, {"votes": {}, "names": {}})
    votes = poll_data["votes"]
    names = poll_data.get("names", {})
    
    total_votes = len(votes)
    vote_counts = [0] * len(options)
    voters_by_option = [[] for _ in options]
    
    for user_id, option_index in votes.items():
        vote_counts[option_index] += 1
        # Get stored name
        user_name = names.get(user_id, f"User#{user_id}")
        voters_by_option[option_index].append(user_name)
    
    results = []
    for i, option in enumerate(options):
        count = vote_counts[i]
        percentage = (count / total_votes * 100) if total_votes > 0 else 0
        bar_length = int(percentage / 10)
        bar = "â–ˆ" * bar_length + "â–‘" * (10 - bar_length)
        
        # Format voter names
        if voters_by_option[i]:
            voter_names = ", ".join(voters_by_option[i][:10])  # Max 10 names
            if len(voters_by_option[i]) > 10:
                voter_names += f" +{len(voters_by_option[i]) - 10} dalÅ¡Ã­ch"
            voters_text = f"\nğŸ‘¤ {voter_names}"
        else:
            voters_text = ""
        
        results.append(f"{NUMBER_EMOJIS[i]} **{option}**\n`{bar}` {percentage:.1f}% ({count}){voters_text}")
    
    return "\n\n".join(results)

def get_live_options_text(options: list, poll_id: str, guild) -> str:
    """Generate options text with live vote counts and voter names"""
    poll_data = active_polls.get(poll_id, {"votes": {}, "names": {}})
    votes = poll_data["votes"]
    names = poll_data.get("names", {})
    total_votes = len(votes)
    vote_counts = [0] * len(options)
    voters_by_option = [[] for _ in options]
    
    for user_id, option_index in votes.items():
        vote_counts[option_index] += 1
        user_name = names.get(user_id, f"User#{user_id}")
        voters_by_option[option_index].append(user_name)
    
    lines = []
    for i, opt in enumerate(options):
        count = vote_counts[i]
        percentage = (count / total_votes * 100) if total_votes > 0 else 0
        bar_length = int(percentage / 5)
        bar = "â–“" * bar_length + "â–‘" * (20 - bar_length)
        
        # Show voter names (max 5 in live view)
        if voters_by_option[i]:
            voter_names = ", ".join(voters_by_option[i][:5])
            if len(voters_by_option[i]) > 5:
                voter_names += f" +{len(voters_by_option[i]) - 5}"
            voters_text = f"\n   ğŸ‘¤ {voter_names}"
        else:
            voters_text = ""
        
        lines.append(f"{NUMBER_EMOJIS[i]} {opt}\n`{bar}` {percentage:.0f}% ({count}){voters_text}")
    
    return "\n".join(lines)

async def run_poll(channel, message, poll_id: str, options: list, author: discord.Member, question: str, end_time: int, guild):
    """Run the poll and end it when time expires"""
    
    while True:
        if poll_id not in active_polls:
            return
        
        remaining = end_time - int(datetime.now(timezone.utc).timestamp())
        
        if remaining <= 0:
            break
        
        # Update embed with current votes and time
        poll_data = active_polls.get(poll_id, {"votes": {}})
        total_votes = len(poll_data["votes"])
        
        options_text = get_live_options_text(options, poll_id, guild)
        
        embed = discord.Embed(
            title="ğŸ“Š ANKETA",
            description=f"**{question}**",
            color=discord.Color.blue()
        )
        embed.add_field(name="MoÅ¾nosti", value=options_text if options_text else "Å½Ã¡dnÃ© hlasy", inline=False)
        embed.add_field(name="â° ZbÃ½vÃ¡", value=f"**{format_time(remaining)}**", inline=True)
        embed.add_field(name="ğŸ‘¥ HlasÅ¯", value=f"**{total_votes}**", inline=True)
        embed.add_field(name="ğŸ‘¤ Autor", value=author.mention, inline=True)
        embed.set_footer(text="Klikni na tlaÄÃ­tko pro hlasovÃ¡nÃ­ â€¢ 1 hlas na osobu")
        
        try:
            await message.edit(embed=embed)
        except:
            pass
        
        # Update interval based on remaining time
        if remaining > 300:  # > 5 min
            await asyncio.sleep(30)
        elif remaining > 60:  # > 1 min
            await asyncio.sleep(10)
        else:
            await asyncio.sleep(3)
    
    # Poll ended - show final results
    if poll_id not in active_polls:
        return
    
    poll_data = active_polls[poll_id]
    total_votes = len(poll_data["votes"])
    
    results_text = get_poll_results(poll_id, options, guild)
    
    embed = discord.Embed(
        title="ğŸ“Š ANKETA UKONÄŒENA!",
        description=f"**{question}**",
        color=discord.Color.green()
    )
    embed.add_field(name="VÃ½sledky", value=results_text if results_text else "Å½Ã¡dnÃ© hlasy", inline=False)
    embed.add_field(name="ğŸ‘¥ Celkem hlasÅ¯", value=f"**{total_votes}**", inline=True)
    embed.add_field(name="ğŸ‘¤ Autor", value=author.mention, inline=True)
    embed.set_footer(text="Anketa skonÄila")
    
    # Disable all buttons
    view = discord.ui.View()
    for i, option in enumerate(options):
        btn = discord.ui.Button(
            label=option[:50],
            style=discord.ButtonStyle.secondary,
            emoji=NUMBER_EMOJIS[i],
            disabled=True
        )
        view.add_item(btn)
    
    try:
        await message.edit(embed=embed, view=view)
    except:
        pass
    
    # Announce winner
    if total_votes > 0:
        vote_counts = [0] * len(options)
        for option_index in poll_data["votes"].values():
            vote_counts[option_index] += 1
        
        max_votes = max(vote_counts)
        winners = [options[i] for i, count in enumerate(vote_counts) if count == max_votes]
        
        if len(winners) == 1:
            winner_text = f"ğŸ† **VÃ­tÄ›z: {winners[0]}** s {max_votes} hlasy!"
        else:
            winner_text = f"ğŸ† **RemÃ­za:** {', '.join(winners)} s {max_votes} hlasy!"
        
        await channel.send(f"ğŸ“Š **Anketa skonÄila!** {author.mention}\n{winner_text}")
    
    # Cleanup
    del active_polls[poll_id]

@bot.tree.command(name="poll", description="VytvoÅ™ anketu s vÃ­ce moÅ¾nostmi")
@app_commands.describe(
    otazka="OtÃ¡zka ankety",
    moznosti="MoÅ¾nosti oddÄ›lenÃ© ÄÃ¡rkou (max 10)",
    cas="Doba trvÃ¡nÃ­ ankety (napÅ™. 5m, 1h, 1d)"
)
async def slash_poll(interaction: discord.Interaction, otazka: str, moznosti: str, cas: str = "5m"):
    # Parse options
    options = [opt.strip() for opt in moznosti.split(",") if opt.strip()]
    
    if len(options) < 2:
        await interaction.response.send_message("âŒ MusÃ­Å¡ zadat alespoÅˆ 2 moÅ¾nosti!", ephemeral=True)
        return
    
    if len(options) > 10:
        await interaction.response.send_message("âŒ Maximum je 10 moÅ¾nostÃ­!", ephemeral=True)
        return
    
    # Parse time
    seconds = parse_time(cas)
    if seconds is None:
        await interaction.response.send_message(
            "âŒ NeplatnÃ½ formÃ¡t Äasu! PouÅ¾ij napÅ™. `5m`, `1h`, `1d`",
            ephemeral=True
        )
        return
    
    if seconds < 30:
        await interaction.response.send_message("âŒ MinimÃ¡lnÃ­ Äas je 30 sekund!", ephemeral=True)
        return
    
    if seconds > 86400 * 7:
        await interaction.response.send_message("âŒ MaximÃ¡lnÃ­ Äas je 7 dnÃ­!", ephemeral=True)
        return
    
    poll_id = str(uuid.uuid4())
    end_time = int(datetime.now(timezone.utc).timestamp()) + seconds
    
    # Create poll data
    active_polls[poll_id] = {"votes": {}, "names": {}, "options": options}
    
    # Build options text
    options_text = "\n".join([f"{NUMBER_EMOJIS[i]} {opt}" for i, opt in enumerate(options)])
    
    embed = discord.Embed(
        title="ğŸ“Š ANKETA",
        description=f"**{otazka}**",
        color=discord.Color.blue()
    )
    embed.add_field(name="MoÅ¾nosti", value=options_text, inline=False)
    embed.add_field(name="â° KonÄÃ­ za", value=format_time(seconds), inline=True)
    embed.add_field(name="ğŸ‘¤ Autor", value=interaction.user.mention, inline=True)
    embed.set_footer(text="Klikni na tlaÄÃ­tko pro hlasovÃ¡nÃ­ â€¢ 1 hlas na osobu")
    
    view = PollView(poll_id, options, interaction.user.id, end_time)
    
    await interaction.response.send_message(embed=embed, view=view)
    message = await interaction.original_response()
    
    # Start poll task
    asyncio.create_task(run_poll(
        interaction.channel,
        message,
        poll_id,
        options,
        interaction.user,
        otazka,
        end_time,
        interaction.guild
    ))

@bot.command(name="poll", aliases=["anketa", "hlasovani"])
async def prefix_poll(ctx, cas: str, *, args: str):
    """!poll 5m OtÃ¡zka? | MoÅ¾nost1, MoÅ¾nost2, MoÅ¾nost3"""
    
    # Parse: question | options
    if "|" not in args:
        await ctx.send("âŒ PouÅ¾ij formÃ¡t: `!poll 5m OtÃ¡zka? | MoÅ¾nost1, MoÅ¾nost2, MoÅ¾nost3`")
        return
    
    parts = args.split("|")
    otazka = parts[0].strip()
    moznosti_str = parts[1].strip() if len(parts) > 1 else ""
    
    options = [opt.strip() for opt in moznosti_str.split(",") if opt.strip()]
    
    if len(options) < 2:
        await ctx.send("âŒ MusÃ­Å¡ zadat alespoÅˆ 2 moÅ¾nosti!")
        return
    
    if len(options) > 10:
        await ctx.send("âŒ Maximum je 10 moÅ¾nostÃ­!")
        return
    
    seconds = parse_time(cas)
    if seconds is None:
        await ctx.send("âŒ NeplatnÃ½ formÃ¡t Äasu! PouÅ¾ij napÅ™. `5m`, `1h`, `1d`")
        return
    
    if seconds < 30:
        await ctx.send("âŒ MinimÃ¡lnÃ­ Äas je 30 sekund!")
        return
    
    if seconds > 86400 * 7:
        await ctx.send("âŒ MaximÃ¡lnÃ­ Äas je 7 dnÃ­!")
        return
    
    poll_id = str(uuid.uuid4())
    end_time = int(datetime.now(timezone.utc).timestamp()) + seconds
    
    active_polls[poll_id] = {"votes": {}, "names": {}, "options": options}
    
    options_text = "\n".join([f"{NUMBER_EMOJIS[i]} {opt}" for i, opt in enumerate(options)])
    
    embed = discord.Embed(
        title="ğŸ“Š ANKETA",
        description=f"**{otazka}**",
        color=discord.Color.blue()
    )
    embed.add_field(name="MoÅ¾nosti", value=options_text, inline=False)
    embed.add_field(name="â° KonÄÃ­ za", value=format_time(seconds), inline=True)
    embed.add_field(name="ğŸ‘¤ Autor", value=ctx.author.mention, inline=True)
    embed.set_footer(text="Klikni na tlaÄÃ­tko pro hlasovÃ¡nÃ­ â€¢ 1 hlas na osobu")
    
    view = PollView(poll_id, options, ctx.author.id, end_time)
    
    message = await ctx.send(embed=embed, view=view)
    
    asyncio.create_task(run_poll(
        ctx.channel,
        message,
        poll_id,
        options,
        ctx.author,
        otazka,
        end_time,
        ctx.guild
    ))

# ============== MUSIC QUIZ ==============

# Czech music database - lyrics snippets with artist and song
CZECH_MUSIC = {
    "rap": [
        # Yzomandias
        {"lyrics": "Hele, vÃ­Å¡ co? UdÄ›lÃ¡me si to po svÃ½m", "artist": "Yzomandias", "song": "Po svÃ½m", "hint": "Y_______"},
        {"lyrics": "PÅ™iÅ¡el jsem z niÄeho, teÄ mÃ¡m vÅ¡echno", "artist": "Yzomandias", "song": "Z niÄeho", "hint": "Y_______"},
        {"lyrics": "ProdÃ¡vÃ¡m sny, lidi kupujou", "artist": "Yzomandias", "song": "Sny", "hint": "Y_______"},
        {"lyrics": "Celej block vÃ­, Å¾e jsem number one", "artist": "Yzomandias", "song": "Block", "hint": "Y_______"},
        {"lyrics": "Runway, dneska letÃ­m vysoko", "artist": "Yzomandias", "song": "Runway", "hint": "Y_______"},
        {"lyrics": "BohatstvÃ­ a slÃ¡va, to je ten sen", "artist": "Yzomandias", "song": "BohatstvÃ­", "hint": "Y_______"},
        {"lyrics": "Milion dÅ¯vodÅ¯ proÄ neskonÄit", "artist": "Yzomandias", "song": "Milion", "hint": "Y_______"},
        {"lyrics": "NemÅ¯Å¾u spÃ¡t, myslÃ­m na cash", "artist": "Yzomandias", "song": "Cash", "hint": "Y_______"},
        # Viktor Sheen
        {"lyrics": "MÅ¯j svÄ›t je Å¡edej, ale nebe je modrÃ½", "artist": "Viktor Sheen", "song": "Barvy", "hint": "Viktor S____"},
        {"lyrics": "NemÃ¡m Äas na fake love, mÃ¡m Äas na real shit", "artist": "Viktor Sheen", "song": "Real Shit", "hint": "Viktor S____"},
        {"lyrics": "ZlatÃ½ Äasy, stÅ™Ã­brnÃ½ vzpomÃ­nky", "artist": "Viktor Sheen", "song": "ZlatÃ½ Äasy", "hint": "Viktor S____"},
        {"lyrics": "NoÄnÃ­ mÄ›sto svÃ­tÃ­, jÃ¡ jdu za svÃ½m", "artist": "Viktor Sheen", "song": "NoÄnÃ­ mÄ›sto", "hint": "Viktor S____"},
        {"lyrics": "ÄŒernÃ½ Mercedes, jedu mÄ›stem", "artist": "Viktor Sheen", "song": "Mercedes", "hint": "Viktor S____"},
        {"lyrics": "Nechci zpÃ¡tky, jdu dopÅ™edu", "artist": "Viktor Sheen", "song": "DopÅ™edu", "hint": "Viktor S____"},
        {"lyrics": "LÃ¡ska je jed, co mi teÄe v Å¾ilÃ¡ch", "artist": "Viktor Sheen", "song": "Jed", "hint": "Viktor S____"},
        # Calin
        {"lyrics": "Jednou budem vÅ¡ichni v zemi, uÅ¾ij si ten den", "artist": "Calin", "song": "Jednou", "hint": "C____"},
        {"lyrics": "Jsem krÃ¡l svÃ½ho svÄ›ta, nikdo mi neporuÄÃ­", "artist": "Calin", "song": "KrÃ¡l", "hint": "C____"},
        {"lyrics": "Money na mÃ½m stole, stress v mojÃ­ hlavÄ›", "artist": "Calin", "song": "Money", "hint": "C____"},
        {"lyrics": "Dream team, my jsme ti nejlepÅ¡Ã­", "artist": "Calin", "song": "Dream team", "hint": "C____"},
        {"lyrics": "PohÃ¡dka o klukovi z ulice", "artist": "Calin", "song": "PohÃ¡dka", "hint": "C____"},
        {"lyrics": "Diamanty na krku, zlato na ruce", "artist": "Calin", "song": "Diamanty", "hint": "C____"},
        # Nik Tendo
        {"lyrics": "MÃ¡m v kapse pÃ¡r stovek a to mi staÄÃ­", "artist": "Nik Tendo", "song": "Stovky", "hint": "Nik T____"},
        {"lyrics": "V hlavÄ› mÃ¡m dÃ©mony, co mÄ› Å¾enou dÃ¡l", "artist": "Nik Tendo", "song": "DÃ©moni", "hint": "Nik T____"},
        {"lyrics": "NeÅ™eÅ¡Ã­m co Å™Ã­kaj, dÄ›lÃ¡m svÃ½", "artist": "Nik Tendo", "song": "SvÃ½", "hint": "Nik T____"},
        {"lyrics": "MÃ¡m stack v kapse, flex na maximum", "artist": "Nik Tendo", "song": "Stack", "hint": "Nik T____"},
        {"lyrics": "Psycho gang, nikdo nÃ¡s nezastavÃ­", "artist": "Nik Tendo", "song": "Psycho", "hint": "Nik T____"},
        {"lyrics": "Praha city, tady jsem vyrostl", "artist": "Nik Tendo", "song": "Praha", "hint": "Nik T____"},
        # Sergei Barracuda
        {"lyrics": "ZaÄÃ­nal jsem dole, teÄ jsem nahoÅ™e", "artist": "Sergei Barracuda", "song": "NahoÅ™e", "hint": "Sergei B_______"},
        {"lyrics": "KaÅ¾dej den hustluju, to je mÅ¯j Å¾ivot", "artist": "Sergei Barracuda", "song": "Hustle", "hint": "Sergei B_______"},
        {"lyrics": "Rest in peace, vzpomÃ­nÃ¡m na ty co odeÅ¡li", "artist": "Sergei Barracuda", "song": "RIP", "hint": "Sergei B_______"},
        {"lyrics": "Southside repre, tohle je nÃ¡Å¡ hood", "artist": "Sergei Barracuda", "song": "Southside", "hint": "Sergei B_______"},
        # Hasan
        {"lyrics": "Celej Å¾ivot makÃ¡m, Å¾Ã¡dnej oddech", "artist": "Hasan", "song": "MakÃ¡m", "hint": "H____"},
        {"lyrics": "ZtracenÃ½ v hudbÄ›, naÅ¡el jsem se v nÃ­", "artist": "Hasan", "song": "Hudba", "hint": "H____"},
        {"lyrics": "Moje mÃ¡ma plÃ¡Äe, kdyÅ¾ mÄ› vidÃ­ v TV", "artist": "Hasan", "song": "MÃ¡ma", "hint": "H____"},
        # Lvcas Dope
        {"lyrics": "Dope boys, tohle je naÅ¡e doba", "artist": "Lvcas Dope", "song": "Dope Boys", "hint": "Lvcas D___"},
        {"lyrics": "PÃ¡lÃ­m jako oheÅˆ, svÃ­tÃ­m jako slunce", "artist": "Lvcas Dope", "song": "OheÅˆ", "hint": "Lvcas D___"},
        {"lyrics": "Gang gang, celÃ¡ crew je tu", "artist": "Lvcas Dope", "song": "Gang", "hint": "Lvcas D___"},
        # Yzomandias + others
        {"lyrics": "NemÃ¡m rÃ¡d lidi, radÅ¡i mÃ¡m prachy", "artist": "Yzomandias", "song": "Prachy", "hint": "Y_______"},
        {"lyrics": "Trap house, tady se to dÄ›je", "artist": "Viktor Sheen", "song": "Trap House", "hint": "Viktor S____"},
        {"lyrics": "Ice na zÃ¡pÄ›stÃ­, ice na krku", "artist": "Calin", "song": "Ice", "hint": "C____"},
        # Marpo
        {"lyrics": "Troublegang aÅ¾ do konce", "artist": "Marpo", "song": "Troublegang", "hint": "M____"},
        {"lyrics": "Nikdy se nevzdÃ¡vÃ¡m, bojuju dÃ¡l", "artist": "Marpo", "song": "Bojuju", "hint": "M____"},
        {"lyrics": "Legendy nikdy neumÃ­rajÃ­", "artist": "Marpo", "song": "Legendy", "hint": "M____"},
        # Ben Cristovao
        {"lyrics": "Asio, asio, tancuj se mnou", "artist": "Ben Cristovao", "song": "Asio", "hint": "Ben C________"},
        {"lyrics": "Bomby, bomby padajÃ­ kolem nÃ¡s", "artist": "Ben Cristovao", "song": "Bomby", "hint": "Ben C________"},
        # Rest
        {"lyrics": "PouliÄnÃ­ hrdina z betonovÃ½ dÅ¾ungle", "artist": "Rest", "song": "Hrdina", "hint": "R___"},
        {"lyrics": "Million dolarÅ¯ v hlavÄ› mÃ¡m", "artist": "Rest", "song": "Million", "hint": "R___"},
        # Dollar Prync
        {"lyrics": "BalÃ­m jeden za druhÃ½m, to je ten vibe", "artist": "Dollar Prync", "song": "Vibe", "hint": "Dollar P____"},
        # Refew
        {"lyrics": "KrÃ¡lovskÃ¡ hra, jsem na trÅ¯nu", "artist": "Refew", "song": "KrÃ¡lovskÃ¡ hra", "hint": "R____"},
        {"lyrics": "Padouch s dobrÃ½m srdcem", "artist": "Refew", "song": "Padouch", "hint": "R____"},
    ],
    "pop": [
        # Mirai
        {"lyrics": "Holky z naÅ¡Ã­ Å¡kolky, chtÄ›ly by mÄ› zpÃ¡tky", "artist": "Mirai", "song": "Holky z naÅ¡Ã­ Å¡kolky", "hint": "M____"},
        {"lyrics": "Na konci dne to bude dobrÃ½", "artist": "Mirai", "song": "DobrÃ½", "hint": "M____"},
        {"lyrics": "Slunce svÃ­tÃ­, svÄ›t je krÃ¡snej", "artist": "Mirai", "song": "Slunce", "hint": "M____"},
        {"lyrics": "PadÃ¡m, vstÃ¡vÃ¡m, jdu dÃ¡l", "artist": "Mirai", "song": "PadÃ¡m", "hint": "M____"},
        {"lyrics": "KdyÅ¾ tÄ› vidÃ­m, srdce mi buÅ¡Ã­", "artist": "Mirai", "song": "Srdce", "hint": "M____"},
        {"lyrics": "Celou noc jsem vzhÅ¯ru, myslÃ­m na tebe", "artist": "Mirai", "song": "Celou noc", "hint": "M____"},
        {"lyrics": "Tady a teÄ, to je ten moment", "artist": "Mirai", "song": "Tady a teÄ", "hint": "M____"},
        # Slza
        {"lyrics": "KdyÅ¾ nemÅ¯Å¾eÅ¡ spÃ¡t a myslÃ­Å¡ na mÄ›", "artist": "Slza", "song": "KdyÅ¾ nemÅ¯Å¾eÅ¡ spÃ¡t", "hint": "S___"},
        {"lyrics": "MÃ¡me se rÃ¡di, tak proÄ to kazit", "artist": "Slza", "song": "MÃ¡me se rÃ¡di", "hint": "S___"},
        {"lyrics": "VÄ›Å™Ã­m na zÃ¡zraky, vÄ›Å™Ã­m na nÃ¡s", "artist": "Slza", "song": "ZÃ¡zraky", "hint": "S___"},
        {"lyrics": "HoÅ™Ã­m pro tebe, shoÅ™ se mnou", "artist": "Slza", "song": "HoÅ™Ã­m", "hint": "S___"},
        {"lyrics": "Nebe nad nÃ¡mi je nekoneÄnÃ½", "artist": "Slza", "song": "Nebe", "hint": "S___"},
        {"lyrics": "Dva lidi, jedna duÅ¡e", "artist": "Slza", "song": "Dva lidi", "hint": "S___"},
        # PokÃ¡Ä
        {"lyrics": "PÅ¯lnoÄnÃ­ vlak mÄ› veze domÅ¯", "artist": "PokÃ¡Ä", "song": "PÅ¯lnoÄnÃ­", "hint": "P____"},
        {"lyrics": "Tancuj, tancuj, dokud mÅ¯Å¾eÅ¡", "artist": "PokÃ¡Ä", "song": "Tancuj", "hint": "P____"},
        {"lyrics": "KaÅ¾dÃ½ rÃ¡no vstÃ¡vÃ¡m s ÃºsmÄ›vem", "artist": "PokÃ¡Ä", "song": "RÃ¡no", "hint": "P____"},
        {"lyrics": "Kafe a cigÃ¡rko, to je moje rÃ¡no", "artist": "PokÃ¡Ä", "song": "Kafe", "hint": "P____"},
        {"lyrics": "Nakupuju v second handu", "artist": "PokÃ¡Ä", "song": "Second hand", "hint": "P____"},
        {"lyrics": "LÃ¡ska je jako pizza, nejlepÅ¡Ã­ kdyÅ¾ je teplÃ¡", "artist": "PokÃ¡Ä", "song": "Pizza", "hint": "P____"},
        # Ewa Farna
        {"lyrics": "JÃ¡ vÃ­m, Å¾e ty vÃ­Å¡, Å¾e jÃ¡ vÃ­m", "artist": "Ewa Farna", "song": "Ty vÃ­Å¡", "hint": "Ewa F____"},
        {"lyrics": "Nikdy nevÃ­Å¡, co ti Å¾ivot pÅ™inese", "artist": "Ewa Farna", "song": "NevÃ­Å¡", "hint": "Ewa F____"},
        {"lyrics": "LÃ¡ska je vÃ¡lka, my jsme vojÃ¡ci", "artist": "Ewa Farna", "song": "VÃ¡lka", "hint": "Ewa F____"},
        {"lyrics": "MÄ›ls mÄ› vÅ¯bec rÃ¡d, nebo to byla jen hra", "artist": "Ewa Farna", "song": "MÄ›ls mÄ› rÃ¡d", "hint": "Ewa F____"},
        {"lyrics": "Ticho, kÅ™iÄÃ­m, ale nikdo neslyÅ¡Ã­", "artist": "Ewa Farna", "song": "Ticho", "hint": "Ewa F____"},
        {"lyrics": "Na ostÅ™Ã­ noÅ¾e balancuju", "artist": "Ewa Farna", "song": "Na ostÅ™Ã­ noÅ¾e", "hint": "Ewa F____"},
        # Marek ZtracenÃ½
        {"lyrics": "CelÃ¡ lÃ©ta jsem hledal tu pravou", "artist": "Marek ZtracenÃ½", "song": "LÃ©ta", "hint": "Marek Z_______"},
        {"lyrics": "SpoleÄnÄ› aÅ¾ na konec svÄ›ta", "artist": "Marek ZtracenÃ½", "song": "SpoleÄnÄ›", "hint": "Marek Z_______"},
        {"lyrics": "DÃ­vÃ¡m se na hvÄ›zdy a vidÃ­m tÄ›", "artist": "Marek ZtracenÃ½", "song": "HvÄ›zdy", "hint": "Marek Z_______"},
        {"lyrics": "AÅ¾ jednou nebudu, vzpomeÅˆ si na mÄ›", "artist": "Marek ZtracenÃ½", "song": "AÅ¾ jednou", "hint": "Marek Z_______"},
        # Aneta LangerovÃ¡
        {"lyrics": "Voda Å¾ivÃ¡, proudÃ­ v mÃ½ch Å¾ilÃ¡ch", "artist": "Aneta LangerovÃ¡", "song": "Voda Å¾ivÃ¡", "hint": "Aneta L_______"},
        {"lyrics": "PtÃ¡k v kleci zpÃ­vÃ¡ o svobodÄ›", "artist": "Aneta LangerovÃ¡", "song": "PtÃ¡k", "hint": "Aneta L_______"},
        # TomÃ¡Å¡ Klus
        {"lyrics": "JÃ¡ jdu dÃ¡l a dÃ¡l, nikdo mÄ› nezastavÃ­", "artist": "TomÃ¡Å¡ Klus", "song": "DÃ¡l", "hint": "TomÃ¡Å¡ K___"},
        {"lyrics": "Do nebe, chci letÄ›t do nebe", "artist": "TomÃ¡Å¡ Klus", "song": "Do nebe", "hint": "TomÃ¡Å¡ K___"},
        {"lyrics": "Ty a jÃ¡, dva blÃ¡zni v tomhle svÄ›tÄ›", "artist": "TomÃ¡Å¡ Klus", "song": "Ty a jÃ¡", "hint": "TomÃ¡Å¡ K___"},
        # Thom Artway
        {"lyrics": "Running through the night, looking for the light", "artist": "Thom Artway", "song": "Running", "hint": "Thom A_____"},
        {"lyrics": "I will never let you go", "artist": "Thom Artway", "song": "Never", "hint": "Thom A_____"},
        # Mig 21
        {"lyrics": "SnadnÃ© je Å¾Ã­t, tÄ›Å¾kÃ© je bÃ½t", "artist": "Mig 21", "song": "SnadnÃ©", "hint": "Mig __"},
        {"lyrics": "Å½iju si svÅ¯j Å¾ivot a je mi dobÅ™e", "artist": "Mig 21", "song": "Å½ivot", "hint": "Mig __"},
        # Lenny
        {"lyrics": "Hell.o, can you hear me calling", "artist": "Lenny", "song": "Hell.o", "hint": "L____"},
        {"lyrics": "Dreaming about you every night", "artist": "Lenny", "song": "Dreaming", "hint": "L____"},
        # RybiÄky 48
        {"lyrics": "PoÅ™Ã¡d ta samÃ¡, poÅ™Ã¡d ta samÃ¡", "artist": "RybiÄky 48", "song": "PoÅ™Ã¡d ta samÃ¡", "hint": "RybiÄky __"},
        {"lyrics": "AdÃ©la, ty jsi moje lÃ¡ska", "artist": "RybiÄky 48", "song": "AdÃ©la", "hint": "RybiÄky __"},
    ],
    "rock": [
        # KryÅ¡tof
        {"lyrics": "AÅ¾ mÄ› jednou potkÃ¡Å¡, budu jinej ÄlovÄ›k", "artist": "KryÅ¡tof", "song": "Jinej ÄlovÄ›k", "hint": "K______"},
        {"lyrics": "BÄ›Å¾Ã­m po ulici a nevÃ­m kam", "artist": "KryÅ¡tof", "song": "BÄ›Å¾Ã­m", "hint": "K______"},
        {"lyrics": "ZÅ¯staÅˆ se mnou jeÅ¡tÄ› chvÃ­li", "artist": "KryÅ¡tof", "song": "ZÅ¯staÅˆ", "hint": "K______"},
        {"lyrics": "Dnes jeÅ¡tÄ› ne, zÃ­tra moÅ¾nÃ¡ jo", "artist": "KryÅ¡tof", "song": "ZÃ­tra", "hint": "K______"},
        {"lyrics": "Ty a jÃ¡, dvÄ› srdce jedno tÄ›lo", "artist": "KryÅ¡tof", "song": "Ty a jÃ¡", "hint": "K______"},
        {"lyrics": "SnÄ›hulÃ¡k, co taje na slunci", "artist": "KryÅ¡tof", "song": "SnÄ›hulÃ¡k", "hint": "K______"},
        {"lyrics": "Cesta, po kterÃ© jdu, nemÃ¡ konce", "artist": "KryÅ¡tof", "song": "Cesta", "hint": "K______"},
        # KabÃ¡t
        {"lyrics": "SnÃ­m svÅ¯j sen a nechci se probudit", "artist": "KabÃ¡t", "song": "SnÃ­m svÅ¯j sen", 