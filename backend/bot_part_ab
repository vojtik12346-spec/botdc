ce_channel.connect()
    elif voice_client.channel != voice_channel:
        await voice_client.move_to(voice_channel)
    
    # Zastavit aktuÃ¡lnÃ­ pÅ™ehrÃ¡vÃ¡nÃ­
    if voice_client.is_playing():
        voice_client.stop()
    
    queue_data = get_music_queue(interaction.guild_id)
    
    # Zkusit pÅ™ehrÃ¡t pÅ™Ã­mo jako stream
    try:
        song = {
            "title": url.split("/")[-1] or "Stream",
            "url": url,
            "duration": 0,
            "requester": interaction.user.display_name
        }
        queue_data["current"] = song
        
        source = discord.FFmpegPCMAudio(url, executable=FFMPEG_EXECUTABLE, **FFMPEG_OPTIONS)
        source = discord.PCMVolumeTransformer(source, volume=queue_data["volume"])
        voice_client.play(source)
        
        embed = discord.Embed(
            title="ğŸµ NynÃ­ hraje",
            description=f"**{song['title']}**",
            color=discord.Color.green()
        )
        embed.add_field(name="ğŸ§ PoÅ¾Ã¡dal", value=song['requester'], inline=True)
        embed.set_footer(text="âš”ï¸ Valhalla Bot â€¢ /musicstop pro zastavenÃ­\nğŸ’¡ Tip: PouÅ¾ij /radio pro ÄeskÃ© stanice!")
        
        await interaction.followup.send(embed=embed)
    except Exception as e:
        await interaction.followup.send(f"âŒ NepodaÅ™ilo se pÅ™ehrÃ¡t: {e}\n\nğŸ’¡ **Tip:** YouTube je na tomto serveru blokovanÃ½. PouÅ¾ij `/radio` pro ÄeskÃ© stanice nebo pÅ™Ã­mÃ½ URL na audio soubor.")

@bot.tree.command(name="skip", description="PÅ™eskoÄ aktuÃ¡lnÃ­ pÃ­sniÄku")
async def skip_command(interaction: discord.Interaction):
    """PÅ™eskoÄÃ­ aktuÃ¡lnÃ­ pÃ­sniÄku"""
    voice_client = interaction.guild.voice_client
    
    if not voice_client or not voice_client.is_connected():
        await interaction.response.send_message("âŒ Bot nenÃ­ ve voice kanÃ¡lu!", ephemeral=True)
        return
    
    if voice_client.is_playing():
        voice_client.stop()
        await interaction.response.send_message("â­ï¸ PÅ™eskoÄeno!")
    else:
        await interaction.response.send_message("âŒ Nic nehraje!", ephemeral=True)

@bot.tree.command(name="musicstop", description="Zastav hudbu a opusÅ¥ voice kanÃ¡l")
async def stop_music_command(interaction: discord.Interaction):
    """ZastavÃ­ hudbu a odpojÃ­ bota"""
    voice_client = interaction.guild.voice_client
    
    if not voice_client:
        await interaction.response.send_message("âŒ Bot nenÃ­ ve voice kanÃ¡lu!", ephemeral=True)
        return
    
    queue_data = get_music_queue(interaction.guild_id)
    queue_data["queue"] = []
    queue_data["current"] = None
    
    await voice_client.disconnect()
    await interaction.response.send_message("ğŸ›‘ Hudba zastavena, bot odpojen!")

@bot.tree.command(name="pause", description="Pozastav hudbu")
async def pause_command(interaction: discord.Interaction):
    """PozastavÃ­ pÅ™ehrÃ¡vÃ¡nÃ­"""
    voice_client = interaction.guild.voice_client
    
    if voice_client and voice_client.is_playing():
        voice_client.pause()
        await interaction.response.send_message("â¸ï¸ Hudba pozastavena!")
    else:
        await interaction.response.send_message("âŒ Nic nehraje!", ephemeral=True)

@bot.tree.command(name="resume", description="PokraÄuj v pÅ™ehrÃ¡vÃ¡nÃ­")
async def resume_command(interaction: discord.Interaction):
    """PokraÄuje v pÅ™ehrÃ¡vÃ¡nÃ­"""
    voice_client = interaction.guild.voice_client
    
    if voice_client and voice_client.is_paused():
        voice_client.resume()
        await interaction.response.send_message("â–¶ï¸ PokraÄuji v pÅ™ehrÃ¡vÃ¡nÃ­!")
    else:
        await interaction.response.send_message("âŒ Hudba nenÃ­ pozastavena!", ephemeral=True)

@bot.tree.command(name="queue", description="Zobraz frontu pÃ­sniÄek")
async def queue_command(interaction: discord.Interaction):
    """ZobrazÃ­ frontu pÃ­sniÄek"""
    queue_data = get_music_queue(interaction.guild_id)
    
    embed = discord.Embed(
        title="ğŸµ Fronta pÃ­sniÄek",
        color=discord.Color.purple()
    )
    
    # AktuÃ¡lnÃ­ pÃ­sniÄka
    if queue_data["current"]:
        current = queue_data["current"]
        embed.add_field(
            name="â–¶ï¸ NynÃ­ hraje",
            value=f"**{current['title']}** ({format_duration(current['duration'])})",
            inline=False
        )
    
    # Fronta
    if queue_data["queue"]:
        queue_list = []
        for i, song in enumerate(queue_data["queue"][:10], 1):
            queue_list.append(f"`{i}.` **{song['title']}** ({format_duration(song['duration'])})")
        
        embed.add_field(
            name=f"ğŸ“‹ DalÅ¡Ã­ v poÅ™adÃ­ ({len(queue_data['queue'])})",
            value="\n".join(queue_list),
            inline=False
        )
        
        if len(queue_data["queue"]) > 10:
            embed.set_footer(text=f"...a dalÅ¡Ã­ch {len(queue_data['queue']) - 10} pÃ­sniÄek")
    else:
        if not queue_data["current"]:
            embed.description = "Fronta je prÃ¡zdnÃ¡! PouÅ¾ij `/play` pro pÅ™idÃ¡nÃ­ hudby."
    
    # Loop status
    if queue_data["loop"]:
        embed.add_field(name="ğŸ” OpakovÃ¡nÃ­", value="Zapnuto", inline=True)
    
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="loop", description="Zapni/vypni opakovÃ¡nÃ­ aktuÃ¡lnÃ­ pÃ­sniÄky")
async def loop_command(interaction: discord.Interaction):
    """Zapne/vypne opakovÃ¡nÃ­"""
    queue_data = get_music_queue(interaction.guild_id)
    queue_data["loop"] = not queue_data["loop"]
    
    if queue_data["loop"]:
        await interaction.response.send_message("ğŸ” OpakovÃ¡nÃ­ zapnuto!")
    else:
        await interaction.response.send_message("â¡ï¸ OpakovÃ¡nÃ­ vypnuto!")

@bot.tree.command(name="volume", description="Nastav hlasitost (0-100)")
@app_commands.describe(level="Hlasitost 0-100")
async def volume_command(interaction: discord.Interaction, level: int):
    """NastavÃ­ hlasitost"""
    if level < 0 or level > 100:
        await interaction.response.send_message("âŒ Hlasitost musÃ­ bÃ½t 0-100!", ephemeral=True)
        return
    
    queue_data = get_music_queue(interaction.guild_id)
    queue_data["volume"] = level / 100
    
    voice_client = interaction.guild.voice_client
    if voice_client and voice_client.source:
        voice_client.source.volume = level / 100
    
    await interaction.response.send_message(f"ğŸ”Š Hlasitost nastavena na **{level}%**")

@bot.tree.command(name="nowplaying", description="Zobraz co prÃ¡vÄ› hraje")
async def nowplaying_command(interaction: discord.Interaction):
    """ZobrazÃ­ aktuÃ¡lnÃ­ pÃ­sniÄku"""
    queue_data = get_music_queue(interaction.guild_id)
    
    if not queue_data["current"]:
        await interaction.response.send_message("âŒ Nic nehraje!", ephemeral=True)
        return
    
    song = queue_data["current"]
    embed = discord.Embed(
        title="ğŸµ NynÃ­ hraje",
        description=f"**{song['title']}**",
        color=discord.Color.green()
    )
    embed.add_field(name="â±ï¸ DÃ©lka", value=format_duration(song['duration']), inline=True)
    embed.add_field(name="ğŸ§ PoÅ¾Ã¡dal", value=song['requester'], inline=True)
    embed.add_field(name="ğŸ” Loop", value="Ano" if queue_data["loop"] else "Ne", inline=True)
    if song.get('thumbnail'):
        embed.set_thumbnail(url=song['thumbnail'])
    embed.set_footer(text="âš”ï¸ Valhalla Bot")
    
    await interaction.response.send_message(embed=embed)

# ============== SOUNDCLOUD MUSIC SEARCH ==============

SOUNDCLOUD_CLIENT_ID = os.environ.get("SOUNDCLOUD_CLIENT_ID", "")
SOUNDCLOUD_CLIENT_SECRET = os.environ.get("SOUNDCLOUD_CLIENT_SECRET", "")
SOUNDCLOUD_API_URL = "https://api.soundcloud.com"

# Cache pro SoundCloud access token
soundcloud_token_cache = {"token": None, "expires": None}

async def get_soundcloud_token() -> str:
    """ZÃ­skej OAuth2 access token pro SoundCloud"""
    global soundcloud_token_cache
    
    # Zkontroluj cache
    if soundcloud_token_cache["token"] and soundcloud_token_cache["expires"]:
        if datetime.now(timezone.utc) < soundcloud_token_cache["expires"]:
            return soundcloud_token_cache["token"]
    
    if not SOUNDCLOUD_CLIENT_ID or not SOUNDCLOUD_CLIENT_SECRET:
        print("[SOUNDCLOUD] Missing credentials!", flush=True)
        return None
    
    async with aiohttp.ClientSession() as session:
        url = f"{SOUNDCLOUD_API_URL}/oauth2/token"
        data = {
            "client_id": SOUNDCLOUD_CLIENT_ID,
            "client_secret": SOUNDCLOUD_CLIENT_SECRET,
            "grant_type": "client_credentials"
        }
        try:
            async with session.post(url, data=data) as resp:
                if resp.status == 200:
                    result = await resp.json()
                    token = result.get("access_token")
                    # Token vyprÅ¡Ã­ za 1 hodinu, refreshneme za 50 minut
                    soundcloud_token_cache["token"] = token
                    soundcloud_token_cache["expires"] = datetime.now(timezone.utc) + timedelta(minutes=50)
                    print("[SOUNDCLOUD] Got new access token", flush=True)
                    return token
                else:
                    print(f"[SOUNDCLOUD] Token error: {resp.status}", flush=True)
        except Exception as e:
            print(f"[SOUNDCLOUD] Token error: {e}", flush=True)
    return None

async def search_soundcloud(query: str, limit: int = 5) -> list:
    """Vyhledej pÃ­sniÄky na SoundCloud API"""
    token = await get_soundcloud_token()
    if not token:
        print("[SOUNDCLOUD] No token available!", flush=True)
        return []
    
    async with aiohttp.ClientSession() as session:
        url = f"{SOUNDCLOUD_API_URL}/tracks"
        params = {"q": query, "limit": limit}
        headers = {"Authorization": f"Bearer {token}"}
        try:
            async with session.get(url, params=params, headers=headers) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    print(f"[SOUNDCLOUD] Found {len(data)} tracks for '{query}'", flush=True)
                    return data
                else:
                    print(f"[SOUNDCLOUD] API error: {resp.status}", flush=True)
        except Exception as e:
            print(f"[SOUNDCLOUD] Search error: {e}", flush=True)
    return []

async def get_soundcloud_stream_url(track: dict) -> str:
    """ZÃ­skej stream URL pro SoundCloud track"""
    token = await get_soundcloud_token()
    if not token:
        return None
    
    track_id = track.get("id")
    if not track_id:
        return None
    
    async with aiohttp.ClientSession() as session:
        headers = {"Authorization": f"Bearer {token}"}
        
        # PouÅ¾ij /streams endpoint pro zÃ­skÃ¡nÃ­ MP3 URL
        streams_url = f"{SOUNDCLOUD_API_URL}/tracks/{track_id}/streams"
        try:
            async with session.get(streams_url, headers=headers) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    # Preferuj http_mp3_128_url, pak hls varianty
                    stream_api_url = (
                        data.get("http_mp3_128_url") or 
                        data.get("hls_mp3_128_url") or 
                        data.get("hls_aac_160_url")
                    )
                    if stream_api_url:
                        # MusÃ­me zÃ­skat skuteÄnou CDN URL pomocÃ­ Authorization header
                        try:
                            async with session.get(stream_api_url, headers=headers, allow_redirects=True) as stream_resp:
                                if stream_resp.status == 200:
                                    # FinÃ¡lnÃ­ URL po redirectu je skuteÄnÃ¡ stream URL
                                    final_url = str(stream_resp.url)
                                    print(f"[SOUNDCLOUD] Got CDN stream URL for track {track_id}", flush=True)
                                    return final_url
                                else:
                                    print(f"[SOUNDCLOUD] Stream redirect error: {stream_resp.status}", flush=True)
                        except Exception as e:
                            print(f"[SOUNDCLOUD] Stream redirect error: {e}", flush=True)
                else:
                    print(f"[SOUNDCLOUD] Streams API error: {resp.status}", flush=True)
        except Exception as e:
            print(f"[SOUNDCLOUD] Stream error: {e}", flush=True)
    
    return None

class SoundCloudSearchView(discord.ui.View):
    def __init__(self, tracks: list, requester: discord.Member, guild_id: int):
        super().__init__(timeout=120)
        self.tracks = tracks
        self.requester = requester
        self.guild_id = guild_id
        
        # PÅ™idej tlaÄÃ­tka pro kaÅ¾dÃ½ track (max 5)
        for i, track in enumerate(tracks[:5]):
            button = discord.ui.Button(
                label=f"{i+1}",
                style=discord.ButtonStyle.primary,
                custom_id=f"sc_play_{i}"
            )
            button.callback = self.create_callback(i)
            self.add_item(button)
    
    def create_callback(self, index: int):
        async def callback(interaction: discord.Interaction):
            await self.play_track(interaction, index)
        return callback
    
    async def play_track(self, interaction: discord.Interaction, index: int):
        track = self.tracks[index]
        
        # Zkontroluj voice
        if not interaction.user.voice:
            await interaction.response.send_message("âŒ MusÃ­Å¡ bÃ½t ve voice kanÃ¡lu!", ephemeral=True)
            return
        
        await interaction.response.defer()
        
        voice_channel = interaction.user.voice.channel
        voice_client = interaction.guild.voice_client
        
        # PÅ™ipojit se k voice
        if not voice_client:
            voice_client = await voice_channel.connect()
        elif voice_client.channel != voice_channel:
            await voice_client.move_to(voice_channel)
        
        # Zastavit aktuÃ¡lnÃ­ pÅ™ehrÃ¡vÃ¡nÃ­
        if voice_client.is_playing():
            voice_client.stop()
        
        queue_data = get_music_queue(interaction.guild_id)
        
        # ZÃ­skej stream URL
        stream_url = await get_soundcloud_stream_url(track)
        
        if not stream_url:
            await interaction.followup.send("âŒ Tato pÃ­sniÄka nenÃ­ dostupnÃ¡ pro streaming!", ephemeral=True)
            return
        
        duration_ms = track.get("duration", 0)
        duration_sec = duration_ms // 1000
        
        song = {
            "title": f"{track.get('user', {}).get('username', 'Unknown')} - {track['title']}",
            "url": stream_url,
            "duration": duration_sec,
            "requester": interaction.user.display_name,
            "thumbnail": track.get("artwork_url")
        }
        queue_data["current"] = song
        
        try:
            source = discord.FFmpegPCMAudio(stream_url, executable=FFMPEG_EXECUTABLE, **FFMPEG_OPTIONS)
            source = discord.PCMVolumeTransformer(source, volume=queue_data["volume"])
            voice_client.play(source)
            
            embed = discord.Embed(
                title="ğŸµ NynÃ­ hraje",
                description=f"**{track['title']}**",
                color=discord.Color.orange()
            )
            embed.add_field(name="ğŸ¤ UmÄ›lec", value=track.get('user', {}).get('username', 'Unknown'), inline=True)
            embed.add_field(name="â±ï¸ DÃ©lka", value=f"{duration_sec // 60}:{duration_sec % 60:02d}", inline=True)
            embed.add_field(name="ğŸ§ PoÅ¾Ã¡dal", value=interaction.user.display_name, inline=True)
            
            if track.get("artwork_url"):
                embed.set_thumbnail(url=track["artwork_url"])
            
            embed.set_footer(text="âš”ï¸ Valhalla Bot â€¢ Powered by SoundCloud")
            
            # Disable all buttons
            for child in self.children:
                child.disabled = True
            
            await interaction.edit_original_response(view=self)
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            print(f"[SOUNDCLOUD] Play error: {e}", flush=True)
            await interaction.followup.send(f"âŒ Chyba pÅ™ehrÃ¡vÃ¡nÃ­: {e}", ephemeral=True)

@bot.tree.command(name="search", description="Vyhledej a pÅ™ehraj pÃ­sniÄku ze SoundCloud")
@app_commands.describe(query="NÃ¡zev pÃ­sniÄky nebo interpreta")
async def search_command(interaction: discord.Interaction, query: str):
    """VyhledÃ¡ pÃ­sniÄky na SoundCloud a nabÃ­dne vÃ½bÄ›r"""
    await interaction.response.defer()
    
    tracks = await search_soundcloud(query, limit=5)
    
    if not tracks:
        await interaction.followup.send(f"âŒ Nic nenalezeno pro: **{query}**", ephemeral=True)
        return
    
    embed = discord.Embed(
        title=f"ğŸ” VÃ½sledky pro: {query}",
        description="Klikni na ÄÃ­slo pro pÅ™ehrÃ¡nÃ­:",
        color=discord.Color.orange()
    )
    
    for i, track in enumerate(tracks[:5]):
        duration_ms = track.get("duration", 0)
        duration_sec = duration_ms // 1000
        duration_str = f"{duration_sec // 60}:{duration_sec % 60:02d}"
        artist = track.get('user', {}).get('username', 'Unknown')
        embed.add_field(
            name=f"{i+1}. {track['title'][:50]}",
            value=f"ğŸ¤ {artist} â€¢ â±ï¸ {duration_str}",
            inline=False
        )
    
    if tracks[0].get("artwork_url"):
        embed.set_thumbnail(url=tracks[0]["artwork_url"])
    
    embed.set_footer(text="âš”ï¸ Valhalla Bot â€¢ Powered by SoundCloud")
    
    view = SoundCloudSearchView(tracks, interaction.user, interaction.guild_id)
    await interaction.followup.send(embed=embed, view=view)

@bot.tree.command(name="playtrack", description="Rychle pÅ™ehraj prvnÃ­ vÃ½sledek vyhledÃ¡vÃ¡nÃ­")
@app_commands.describe(query="NÃ¡zev pÃ­sniÄky nebo interpreta")
async def playtrack_command(interaction: discord.Interaction, query: str):
    """PÅ™ehraje prvnÃ­ vÃ½sledek vyhledÃ¡vÃ¡nÃ­ ze SoundCloud"""
    if not interaction.user.voice:
        await interaction.response.send_message("âŒ MusÃ­Å¡ bÃ½t ve voice kanÃ¡lu!", ephemeral=True)
        return
    
    await interaction.response.defer()
    
    tracks = await search_soundcloud(query, limit=1)
    
    if not tracks:
        await interaction.followup.send(f"âŒ Nic nenalezeno pro: **{query}**", ephemeral=True)
        return
    
    track = tracks[0]
    
    # ZÃ­skej stream URL
    stream_url = await get_soundcloud_stream_url(track)
    
    if not stream_url:
        await interaction.followup.send("âŒ Tato pÃ­sniÄka nenÃ­ dostupnÃ¡ pro streaming!", ephemeral=True)
        return
    
    voice_channel = interaction.user.voice.channel
    voice_client = interaction.guild.voice_client
    
    # PÅ™ipojit se k voice
    if not voice_client:
        voice_client = await voice_channel.connect()
    elif voice_client.channel != voice_channel:
        await voice_client.move_to(voice_channel)
    
    # Zastavit aktuÃ¡lnÃ­ pÅ™ehrÃ¡vÃ¡nÃ­
    if voice_client.is_playing():
        voice_client.stop()
    
    queue_data = get_music_queue(interaction.guild_id)
    
    duration_ms = track.get("duration", 0)
    duration_sec = duration_ms // 1000
    
    song = {
        "title": f"{track.get('user', {}).get('username', 'Unknown')} - {track['title']}",
        "url": stream_url,
        "duration": duration_sec,
        "requester": interaction.user.display_name,
        "thumbnail": track.get("artwork_url")
    }
    queue_data["current"] = song
    
    try:
        source = discord.FFmpegPCMAudio(stream_url, executable=FFMPEG_EXECUTABLE, **FFMPEG_OPTIONS)
        source = discord.PCMVolumeTransformer(source, volume=queue_data["volume"])
        voice_client.play(source)
        
        embed = discord.Embed(
            title="ğŸµ NynÃ­ hraje",
            description=f"**{track['title']}**",
            color=discord.Color.orange()
        )
        embed.add_field(name="ğŸ¤ UmÄ›lec", value=track.get('user', {}).get('username', 'Unknown'), inline=True)
        embed.add_field(name="â±ï¸ DÃ©lka", value=f"{duration_sec // 60}:{duration_sec % 60:02d}", inline=True)
        embed.add_field(name="ğŸ§ PoÅ¾Ã¡dal", value=interaction.user.display_name, inline=True)
        
        if track.get("artwork_url"):
            embed.set_thumbnail(url=track["artwork_url"])
        
        embed.set_footer(text="âš”ï¸ Valhalla Bot â€¢ Powered by SoundCloud")
        
        await interaction.followup.send(embed=embed)
        
    except Exception as e:
        print(f"[SOUNDCLOUD] Play error: {e}", flush=True)
        await interaction.followup.send(f"âŒ Chyba pÅ™ehrÃ¡vÃ¡nÃ­: {e}")

# ============== GIVEAWAY SYSTEM ==============

active_giveaways = {}

class GiveawayView(discord.ui.View):
    def __init__(self, giveaway_id: str, prize: str, end_time: datetime, host_id: int):
        super().__init__(timeout=None)
        self.giveaway_id = giveaway_id
        self.prize = prize
        self.end_time = end_time
        self.host_id = host_id
        self.participants = set()
    
    @discord.ui.button(label="ğŸ‰ ZÃºÄastnit se", style=discord.ButtonStyle.green, custom_id="giveaway_join")
    async def join_giveaway(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = interaction.user.id
        
        if user_id in self.participants:
            self.participants.discard(user_id)
            await interaction.response.send_message("âŒ OdhlÃ¡sil ses ze soutÄ›Å¾e!", ephemeral=True)
        else:
            self.participants.add(user_id)
            await interaction.response.send_message("âœ… Jsi pÅ™ihlÃ¡Å¡en do soutÄ›Å¾e! HodnÄ› Å¡tÄ›stÃ­! ğŸ€", ephemeral=True)
        
        # Update embed with participant count
        await self.update_embed(interaction.message)
    
    async def update_embed(self, message):
        embed = message.embeds[0]
        embed.set_field_at(1, name="ğŸ‘¥ ÃšÄastnÃ­kÅ¯", value=str(len(self.participants)), inline=True)
        await message.edit(embed=embed)

@bot.tree.command(name="giveaway", description="VytvoÅ™ novou soutÄ›Å¾ (jen admin)")
@app_commands.describe(
    cas="Doba trvÃ¡nÃ­ soutÄ›Å¾e (napÅ™. 1h, 1d, 7d)",
    vyhry="PoÄet vÃ½hercÅ¯",
    cena="Co se vyhrÃ¡vÃ¡"
)
@app_commands.checks.has_permissions(administrator=True)
async def giveaway_command(interaction: discord.Interaction, cas: str, vyhry: int, cena: str):
    """VytvoÅ™Ã­ novou giveaway soutÄ›Å¾"""
    seconds = parse_time(cas)
    
    if seconds is None:
        await interaction.response.send_message("âŒ NeplatnÃ½ formÃ¡t Äasu! PouÅ¾ij napÅ™. 1h, 1d, 7d", ephemeral=True)
        return
    
    if vyhry < 1:
        await interaction.response.send_message("âŒ PoÄet vÃ½hercÅ¯ musÃ­ bÃ½t alespoÅˆ 1!", ephemeral=True)
        return
    
    end_time = datetime.now(timezone.utc) + timedelta(seconds=seconds)
    giveaway_id = f"{interaction.guild_id}_{interaction.channel_id}_{int(datetime.now().timestamp())}"
    
    # Create embed
    embed = discord.Embed(
        title="ğŸ GIVEAWAY!",
        description=f"**{cena}**",
        color=discord.Color.gold()
    )
    embed.add_field(name="ğŸ† PoÄet vÃ½hercÅ¯", value=str(vyhry), inline=True)
    embed.add_field(name="ğŸ‘¥ ÃšÄastnÃ­kÅ¯", value="0", inline=True)
    embed.add_field(name="â° KonÄÃ­", value=f"<t:{int(end_time.timestamp())}:R>", inline=True)
    embed.add_field(name="ğŸ® Hostitel", value=interaction.user.mention, inline=False)
    embed.set_footer(text="Klikni na tlaÄÃ­tko pro ÃºÄast!")
    
    # Create view
    view = GiveawayView(giveaway_id, cena, end_time, interaction.user.id)
    view.winners_count = vyhry
    
    await interaction.response.send_message(embed=embed, view=view)
    message = await interaction.original_response()
    
    # Store giveaway
    active_giveaways[giveaway_id] = {
        "message_id": message.id,
        "channel_id": interaction.channel_id,
        "guild_id": interaction.guild_id,
        "prize": cena,
        "winners_count": vyhry,
        "end_time": end_time,
        "host_id": interaction.user.id,
        "view": view
    }
    
    # Schedule end
    bot.loop.create_task(end_giveaway_after(giveaway_id, seconds))

async def end_giveaway_after(giveaway_id: str, seconds: int):
    """End giveaway after specified time"""
    await asyncio.sleep(seconds)
    await end_giveaway(giveaway_id)

async def end_giveaway(giveaway_id: str):
    """End a giveaway and pick winners"""
    if giveaway_id not in active_giveaways:
        return
    
    giveaway = active_giveaways[giveaway_id]
    view = giveaway["view"]
    
    channel = bot.get_channel(giveaway["channel_id"])
    if not channel:
        return
    
    try:
        message = await channel.fetch_message(giveaway["message_id"])
    except:
        return
    
    participants = list(view.participants)
    winners_count = min(giveaway["winners_count"], len(participants))
    
    if winners_count == 0:
        # No participants
        embed = discord.Embed(
            title="ğŸ GIVEAWAY UKONÄŒEN",
            description=f"**{giveaway['prize']}**\n\nğŸ˜¢ Nikdo se nezÃºÄastnil!",
            color=discord.Color.red()
        )
        await message.edit(embed=embed, view=None)
    else:
        # Pick winners
        import random
        winners = random.sample(participants, winners_count)
        winners_mentions = ", ".join([f"<@{w}>" for w in winners])
        
        embed = discord.Embed(
            title="ğŸ‰ GIVEAWAY UKONÄŒEN!",
            description=f"**{giveaway['prize']}**",
            color=discord.Color.green()
        )
        embed.add_field(name="ğŸ† VÃ½herci", value=winners_mentions, inline=False)
        embed.add_field(name="ğŸ‘¥ Celkem ÃºÄastnÃ­kÅ¯", value=str(len(participants)), inline=True)
        
        await message.edit(embed=embed, view=None)
        
        # Announce winners
        await channel.send(f"ğŸ‰ Gratulujeme {winners_mentions}! VyhrÃ¡li jste **{giveaway['prize']}**!")
    
    # Remove from active
    del active_giveaways[giveaway_id]

@bot.tree.command(name="greroll", description="Znovu vylosuj vÃ½herce (jen admin)")
@app_commands.describe(message_id="ID zprÃ¡vy s giveaway")
@app_commands.checks.has_permissions(administrator=True)
async def giveaway_reroll(interaction: discord.Interaction, message_id: str):
    """Reroll giveaway winners"""
    try:
        message = await interaction.channel.fetch_message(int(message_id))
    except:
        await interaction.response.send_message("âŒ ZprÃ¡va nenalezena!", ephemeral=True)
        return
    
    # Find giveaway in history or just pick random from reactions
    await interaction.response.send_message("ğŸ² Funkce reroll bude brzy dostupnÃ¡!", ephemeral=True)

@giveaway_command.error
async def giveaway_error(interaction: discord.Interaction, error):
    if isinstance(error, app_commands.MissingPermissions):
        await interaction.response.send_message("âŒ Pouze administrÃ¡tor mÅ¯Å¾e vytvÃ¡Å™et soutÄ›Å¾e!", ephemeral=True)
    else:
        await interaction.response.send_message(f"âŒ Chyba: {error}", ephemeral=True)

# ============== COUNTDOWN COMMANDS ==============

@bot.tree.command(name="odpocet", description="SpusÅ¥ odpoÄet (napÅ™. 2m, 5m, 1h)")
@app_commands.describe(
    cas="ÄŒas odpoÄtu (napÅ™. 30s, 2m, 1h, 1d)",
    duvod="DÅ¯vod/popis odpoÄtu (volitelnÃ©)"
)
async def slash_odpocet(interaction: discord.Interaction, cas: str, duvod: str = None):
    seconds = parse_time(cas)
    
    if seconds is None:
        await interaction.response.send_message(
            "âŒ NeplatnÃ½ formÃ¡t Äasu! PouÅ¾ij napÅ™. `30s`, `2m`, `1h`, `1d`",
            ephemeral=True
        )
        return
    
    if seconds < 5:
        await interaction.response.send_message("âŒ MinimÃ¡lnÃ­ Äas je 5 sekund!", ephemeral=True)
        return
    
    if seconds > 86400 * 7:
        await interaction.response.send_message("âŒ MaximÃ¡lnÃ­ Äas je 7 dnÃ­!", ephemeral=True)
        return
    
    countdown_id = str(uuid.uuid4())
    end_time = int(datetime.now(timezone.utc).timestamp()) + seconds
    
    embed = discord.Embed(
        title="â° ODPOÄŒET",
        description=f"**{duvod}**" if duvod else "OdpoÄet bÄ›Å¾Ã­...",
        color=discord.Color.blue()
    )
    embed.add_field(name="â³ ZbÃ½vÃ¡", value=f"**{format_time(seconds)}**", inline=True)
    embed.add_field(name="ğŸ‘¤ Spustil", value=interaction.user.mention, inline=True)
    embed.set_footer(text=f"KonÄÃ­: {datetime.fromtimestamp(end_time).strftime('%H:%M:%S')}")
    
    view = CountdownView(countdown_id, interaction.user.id)
    
    await interaction.response.send_message(embed=embed, view=view)
    message = await interaction.original_response()
    
    active_countdowns[countdown_id] = {"cancelled": False}
    
    asyncio.create_task(run_countdown(
        interaction.channel,
        message,
        end_time,
        countdown_id,
        interaction.user,
        duvod
    ))

@bot.command(name="odpocet", aliases=["countdown", "timer"])
async def prefix_odpocet(ctx, cas: str, *, duvod: str = None):
    """!odpocet 2m [dÅ¯vod] - SpusÅ¥ odpoÄet"""
    seconds = parse_time(cas)
    
    if seconds is None:
        await ctx.send("âŒ NeplatnÃ½ formÃ¡t Äasu! PouÅ¾ij napÅ™. `30s`, `2m`, `1h`, `1d`")
        return
    
    if seconds < 5:
        await ctx.send("âŒ MinimÃ¡lnÃ­ Äas je 5 sekund!")
        return
    
    if seconds > 86400 * 7:
        await ctx.send("âŒ MaximÃ¡lnÃ­ Äas je 7 dnÃ­!")
        return
    
    countdown_id = str(uuid.uuid4())
    end_time = int(datetime.now(timezone.utc).timestamp()) + seconds
    
    embed = discord.Embed(
        title="â° ODPOÄŒET",
        description=f"**{duvod}**" if duvod else "OdpoÄet bÄ›Å¾Ã­...",
        color=discord.Color.blue()
    )
    embed.add_field(name="â³ ZbÃ½vÃ¡", value=f"**{format_time(seconds)}**", inline=True)
    embed.add_field(name="ğŸ‘¤ Spustil", value=ctx.author.mention, inline=True)
    embed.set_footer(text=f"KonÄÃ­: {datetime.fromtimestamp(end_time).strftime('%H:%M:%S')}")
    
    view = CountdownView(countdown_id, ctx.author.id)
    
    message = await ctx.send(embed=embed, view=view)
    
    active_countdowns[countdown_id] = {"cancelled": False}
    
    asyncio.create_task(run_countdown(
        ctx.channel,
        message,
        end_time,
        countdown_id,
        ctx.author,
        duvod
    ))

@bot.tree.command(name="help", description="Zobraz nÃ¡povÄ›du")
async def slash_help(interaction: discord.Interaction):
    embed = discord.Embed(
        title="âš”ï¸ Valhalla Bot - PÅ™Ã­kazy",
        color=discord.Color.blue()
    )
    embed.add_field(
        name="â° OdpoÄet",
        value="`/odpocet [Äas] [dÅ¯vod]`",
        inline=False
    )
    embed.add_field(
        name="ğŸ“Š Ankety",
        value="`/poll [otÃ¡zka] [moÅ¾nosti] [Äas]`",
        inline=False
    )
    embed.add_field(
        name="ğŸµ HudebnÃ­ kvÃ­z",
        value="`/hudba [Å¾Ã¡nr]` - rap, pop, rock, classic",
        inline=False
    )
    embed.add_field(
        name="ğŸ¬ FilmovÃ½ kvÃ­z",
        value="`/film [Å¾Ã¡nr]` - ÄeskÃ©, hollywood, komedie, akÄnÃ­, horor, scifi",
        inline=False
    )
    embed.add_field(
        name="ğŸ¤” Pravda/LeÅ¾",
        value="`/pravda [kategorie]` - zvÃ­Å™ata, vÄ›da, historie, tÄ›lo, jÃ­dlo, Äesko, bizarnÃ­",
        inline=False
    )
    embed.add_field(
        name="ğŸ›‘ Zastavit kvÃ­z",
        value="`/stop` - zastavÃ­ bÄ›Å¾Ã­cÃ­ kvÃ­z",
        inline=False
    )
    embed.add_field(
        name="â±ï¸ FormÃ¡ty Äasu",
        value="`30s`, `2m`, `1h`, `1d`",
        inline=False
    )
    embed.add_field(
        name="ğŸ† Level systÃ©m",
        value="`/gamelevel` `/top` `/daily` `/hry` `/ukoly`",
        inline=False
    )
    embed.add_field(
        name="ğŸµ Hudba & RÃ¡dio",
        value="`/search [nÃ¡zev]` - vyhledej na SoundCloud\n`/playtrack [nÃ¡zev]` - rychlÃ© pÅ™ehrÃ¡nÃ­\n`/radio [stanice]` - pÅ™ehraj rÃ¡dio\n`/radiolist` - seznam stanic",
        inline=False
    )
    await interaction.response.send_message(embed=embed)

@bot.command(name="pomoc")
async def prefix_help(ctx):
    """!pomoc - Zobraz nÃ¡povÄ›du"""
    embed = discord.Embed(
        title="âš”ï¸ Valhalla Bot - PÅ™Ã­kazy",
        color=discord.Color.blue()
    )
    embed.add_field(
        name="â° OdpoÄet",
        value="`!odpocet [Äas] [dÅ¯vod]`",
        inline=False
    )
    embed.add_field(
        name="ğŸ“Š Ankety",
        value="`!poll 5m OtÃ¡zka? | MoÅ¾nost1, MoÅ¾nost2`",
        inline=False
    )
    embed.add_field(
        name="ğŸµ HudebnÃ­ kvÃ­z",
        value="`!hudba [rap/pop/rock/classic]`",
        inline=False
    )
    embed.add_field(
        name="ğŸ¬ FilmovÃ½ kvÃ­z",
        value="`!film [ceske/hollywood/komedie/akcni/horor/scifi]`",
        inline=False
    )
    embed.add_field(
        name="ğŸ¤” Pravda/LeÅ¾",
        value="`!pravda [kategorie]` - zvirata, veda, historie, telo, jidlo, cesko, bizarni",
        inline=False
    )
    embed.add_field(
        name="ğŸ›‘ Zastavit kvÃ­z",
        value="`!stop` - zastavÃ­ bÄ›Å¾Ã­cÃ­ kvÃ­z",
        inline=False
    )
    embed.add_field(
        name="ğŸ† Level systÃ©m",
        value="`!level` `!top` `!daily` `!hry` `!ukoly`",
        inline=False
    )
    msg = await ctx.send(embed=embed)
    asyncio.create_task(delete_after(msg, 60))  # SmaÅ¾e po 5 min

@bot.command(name="prikazy")
@commands.has_permissions(administrator=True)
async def send_commands_info(ctx):
    """!prikazy - PoÅ¡le trvalou zprÃ¡vu s pÅ™ehledem pÅ™Ã­kazÅ¯ (jen admin)"""
    
    # Delete the command message
    try:
        await ctx.message.delete()
    except:
        pass
    
    # Main embed
    embed = discord.Embed(
        title="âš”ï¸ VALHALLA BOT - PÅ˜ÃKAZY",
        description="KompletnÃ­ pÅ™ehled vÅ¡ech dostupnÃ½ch pÅ™Ã­kazÅ¯",
        color=discord.Color.blue()
    )
    
    # KvÃ­zy
    embed.add_field(
        name="ğŸµ HUDEBNÃ KVÃZ",
        value="```/hudba [Å¾Ã¡nr]\n!hudba [rap/pop/rock/classic]```\nHÃ¡dej interpreta podle textu pÃ­snÄ›!\n**+25 XP** za sprÃ¡vnou odpovÄ›Ä",
        inline=False
    )
    
    embed.add_field(
        name="ğŸ¬ FILMOVÃ KVÃZ",
        value="```/film [Å¾Ã¡nr]\n!film [ceske/hollywood/komedie/akcni/horor/scifi]```\nHÃ¡dej film podle slavnÃ© hlÃ¡Å¡ky!\n**+25 XP** za sprÃ¡vnou odpovÄ›Ä",
        inline=False
    )
    
    embed.add_field(
        name="ğŸ¤” PRAVDA NEBO LEÅ½",
        value="```/pravda [kategorie]\n!pravda [zvirata/veda/historie/telo/jidlo/cesko/bizarni]```\nJe tento fakt pravdivÃ½?\n**+15 XP** za sprÃ¡vnou odpovÄ›Ä",
        inline=False
    )
    
    # Level systÃ©m
    embed.add_field(
        name="ğŸ“Š LEVEL SYSTÃ‰M",
        value="```/gamelevel nebo !level``` Zobraz svÅ¯j level a statistiky\n```/top nebo !top``` Å½ebÅ™Ã­Äek TOP 10 hrÃ¡ÄÅ¯\n```/daily nebo !daily``` DennÃ­ bonus **+100 XP** + streak",
        inline=False
    )
    
    # HernÃ­ systÃ©m
    embed.add_field(
        name="ğŸ® HRY NA PC",
        value="```/hry nebo !hry``` TvÃ© odemÄenÃ© hry a Äas hranÃ­\n```/ukoly [hra] nebo !ukoly [hra]``` Ãškoly pro konkrÃ©tnÃ­ hru\n\n**AutomatickÃ© XP za hranÃ­:**\nâ€¢ +5 XP za 10 minut hranÃ­\nâ€¢ Max 200 XP/den\nâ€¢ +25 XP za odemÄenÃ­ novÃ© hry",
        inline=False
    )
    
    # Utility
    embed.add_field(
        name="â° UTILITY",
        value="```/odpocet [Äas] [dÅ¯vod]\n!odpocet 5m PÅ™estÃ¡vka```\nSpustÃ­ odpoÄet s notifikacÃ­\n```/poll [otÃ¡zka] [moÅ¾nosti] [Äas]\n!poll 5m OtÃ¡zka? | Ano, Ne```\nVytvoÅ™Ã­ anketu s hlasovÃ¡nÃ­m",
        inline=False
    )
    
    embed.add_field(
        name="ğŸ›‘ OSTATNÃ",
        value="```/stop nebo !stop``` ZastavÃ­ bÄ›Å¾Ã­cÃ­ kvÃ­z\n```/help nebo !pomoc``` ZobrazÃ­ nÃ¡povÄ›du",
        inline=False
    )
    
    embed.set_footer(text="ğŸ’¡ Valhalla Bot â€¢ Hraj hry, plÅˆ Ãºkoly a staÅˆ se legendou!")
    
    await ctx.send(embed=embed)
    
    # Second embed - XP info
    xp_embed = discord.Embed(
        title="âœ¨ JAK ZÃSKAT XP",
        color=discord.Color.gold()
    )
    
    xp_embed.add_field(
        name="ğŸ¯ KvÃ­zy",
        value="â€¢ HudebnÃ­/FilmovÃ½ kvÃ­z: **+25 XP**\nâ€¢ Pravda/LeÅ¾: **+15 XP**",
        inline=True
    )
    
    xp_embed.add_field(
        name="ğŸ® HranÃ­ her",
        value="â€¢ 10 minut hranÃ­: **+5 XP**\nâ€¢ OdemÄenÃ­ hry: **+25 XP**\nâ€¢ Max dennÄ›: **200 XP**",
        inline=True
    )
    
    xp_embed.add_field(
        name="ğŸ Bonusy",
        value="â€¢ DennÃ­ bonus: **+100 XP**\nâ€¢ Streak bonus: **+10 XP/den**\nâ€¢ SplnÄ›nÃ½ Ãºkol: **+50-1500 XP**",
        inline=True
    )
    
    xp_embed.add_field(
        name="ğŸ“ˆ LEVELY",
        value="ğŸŒ± Lvl 1 â†’ ğŸŒ¿ Lvl 2 â†’ ğŸŒ³ Lvl 3 â†’ â­ Lvl 4 â†’ ğŸŒŸ Lvl 5 â†’ ğŸ’« Lvl 10 â†’ ğŸ”¥ Lvl 15 â†’ ğŸ’ Lvl 20 â†’ ğŸ‘‘ Lvl 25 â†’ ğŸ† Lvl 30",
        inline=False
    )
    
    await ctx.send(embed=xp_embed)

@bot.command(name="herniinfo")
@commands.has_permissions(administrator=True)
async def send_game_info(ctx):
    """!herniinfo - PoÅ¡le trvalou zprÃ¡vu s hernÃ­mi pÅ™Ã­kazy do kanÃ¡lu 1468355022159872073 (jen admin)"""
    
    # Delete the command message
    try:
        await ctx.message.delete()
    except:
        pass
    
    # ZÃ­skÃ¡nÃ­ cÃ­lovÃ©ho kanÃ¡lu
    target_channel = bot.get_channel(GAME_NOTIFICATION_CHANNEL)
    if not target_channel:
        await ctx.send("âŒ NepodaÅ™ilo se najÃ­t cÃ­lovÃ½ kanÃ¡l!", delete_after=10)
        return
    
    # === HLAVNÃ EMBED - HERNÃ PÅ˜ÃKAZY ===
    main_embed = discord.Embed(
        title="ğŸ® HERNÃ SYSTÃ‰M - PÅ˜ÃKAZY",
        description="KompletnÃ­ pÅ™ehled hernÃ­ch pÅ™Ã­kazÅ¯ a jak zÃ­skat XP",
        color=discord.Color.green()
    )
    
    main_embed.add_field(
        name="ğŸ“Š `/gamelevel` nebo `!level`",
        value="**ZobrazÃ­ tvÅ¯j hernÃ­ profil:**\n"
              "â€¢ AktuÃ¡lnÃ­ level a XP\n"
              "â€¢ PoÄet odehranÃ½ch kvÃ­zÅ¯\n"
              "â€¢ PÅ™esnost odpovÄ›dÃ­\n"
              "â€¢ AktuÃ¡lnÃ­ streak\n"
              "â€¢ Progress do dalÅ¡Ã­ho levelu\n"
              "ğŸ’¡ *MÅ¯Å¾eÅ¡ zadat i jinÃ©ho hrÃ¡Äe: `/gamelevel @hrac`*",
        inline=False
    )
    
    main_embed.add_field(
        name="ğŸ† `/top` nebo `!top`",
        value="**ZobrazÃ­ Å¾ebÅ™Ã­Äek TOP 10 hrÃ¡ÄÅ¯:**\n"
              "â€¢ SeÅ™azeno podle XP\n"
              "â€¢ VidÃ­Å¡ level, XP a badge kaÅ¾dÃ©ho hrÃ¡Äe\n"
              "â€¢ SoutÄ›Å¾ s ostatnÃ­mi o prvnÃ­ mÃ­sto!",
        inline=False
    )
    
    main_embed.add_field(
        name="ğŸ `/daily` nebo `!daily`",
        value="**DennÃ­ bonus - zÃ­skej ZDARMA:**\n"
              "â€¢ **+100 XP** kaÅ¾dÃ½ den\n"
              "â€¢ **+10 XP bonus** za kaÅ¾dÃ½ den streak\n"
              "â€¢ Streak = po sobÄ› jdoucÃ­ dny\n"
              "â€¢ Reset streaku = vynechanÃ½ den\n"
              "â° *Resetuje se o pÅ¯lnoci*",
        inline=False
    )
    
    main_embed.add_field(
        name="ğŸ•¹ï¸ `/hry` nebo `!hry`",
        value="**ZobrazÃ­ tvÃ© odemÄenÃ© hry:**\n"
              "â€¢ Seznam her kterÃ© jsi hrÃ¡l\n"
              "â€¢ CelkovÃ½ Äas hranÃ­ kaÅ¾dÃ© hry\n"
              "â€¢ PoÄet odemÄenÃ½ch her\n"
              "â€¢ Emoji podle kategorie hry",
        inline=False
    )
    
    main_embed.add_field(
        name="ğŸ“‹ `/ukoly [hra]` nebo `!ukoly [hra]`",
        value="**ZobrazÃ­ Ãºkoly pro konkrÃ©tnÃ­ hru:**\n"
              "â€¢ Ãškoly podle odehranÃ©ho Äasu\n"
              "â€¢ XP odmÄ›ny za splnÄ›nÃ­\n"
              "â€¢ VidÃ­Å¡ kterÃ© Ãºkoly mÃ¡Å¡ hotovÃ© âœ…\n"
              "â€¢ PÅ™Ã­klad: `/ukoly Minecraft`",
        inline=False
    )
    
    main_embed.set_footer(text="Tyto odpovÄ›di se automaticky maÅ¾ou po 1 minutÄ›")
    
    # === DRUHÃ EMBED - JAK ZÃSKAT XP ===
    xp_embed = discord.Embed(
        title="âœ¨ JAK ZÃSKAT XP",
        description="VÅ¡echny zpÅ¯soby jak rychle levelovat",
        color=discord.Color.gold()
    )
    
    xp_embed.add_field(
        name="ğŸµ HudebnÃ­ kvÃ­z `/hudba`",
        value="**+25 XP** za sprÃ¡vnou odpovÄ›Ä\n*HÃ¡dej interpreta podle textu*",
        inline=True
    )
    
    xp_embed.add_field(
        name="ğŸ¬ FilmovÃ½ kvÃ­z `/film`",
        value="**+25 XP** za sprÃ¡vnou odpovÄ›Ä\n*HÃ¡dej film podle hlÃ¡Å¡ky*",
        inline=True
    )
    
    xp_embed.add_field(
        name="ğŸ¤” Pravda/LeÅ¾ `/pravda`",
        value="**+15 XP** za sprÃ¡vnou odpovÄ›Ä\n*Je fakt pravdivÃ½?*",
        inline=True
    )
    
    xp_embed.add_field(
        name="ğŸ® HranÃ­ her na PC",
        value="**+5 XP** za kaÅ¾dÃ½ch 10 minut hranÃ­\n"
              "**+25 XP** bonus za odemÄenÃ­ novÃ© hry\n"
              "**Max 200 XP/den** z hranÃ­\n"
              "*Automaticky detekuje hry pÅ™es Discord*",
        inline=False
    )
    
    xp_embed.add_field(
        name="ğŸ DennÃ­ bonus",
        value="**+100 XP** kaÅ¾dÃ½ den\n"
              "**+10 XP** bonus za streak",
        inline=True
    )
    
    xp_embed.add_field(
        name="ğŸ… SplnÄ›nÃ© Ãºkoly",
        value="**+50 aÅ¾ +1500 XP**\n"
              "Podle nÃ¡roÄnosti Ãºkolu",
        inline=True
    )
    
    # === TÅ˜ETÃ EMBED - LEVEL SYSTÃ‰M ===
    level_embed = discord.Embed(
        title="ğŸ“ˆ LEVEL SYSTÃ‰M",
        description="ÄŒÃ­m vÃ­c XP, tÃ­m vyÅ¡Å¡Ã­ level a lepÅ¡Ã­ badge!",
        color=discord.Color.purple()
    )
    
    level_embed.add_field(
        name="ğŸ… Odznaky podle levelu",
        value="ğŸŒ± **Lvl 1** â†’ NovÃ¡Äek\n"
              "ğŸŒ¿ **Lvl 2** â†’ ZaÄÃ¡teÄnÃ­k\n"
              "ğŸŒ³ **Lvl 3** â†’ HrÃ¡Ä\n"
              "â­ **Lvl 4** â†’ PokroÄilÃ½\n"
              "ğŸŒŸ **Lvl 5** â†’ ZkuÅ¡enÃ½\n"
              "ğŸ’« **Lvl 10** â†’ VeterÃ¡n\n"
              "ğŸ”¥ **Lvl 15** â†’ Expert\n"
              "ğŸ’ **Lvl 20** â†’ Mistr\n"
              "ğŸ‘‘ **Lvl 25** â†’ Å ampion\n"
              "ğŸ† **Lvl 30** â†’ Legenda",
        inline=True
    )
    
    level_embed.add_field(
        name="ğŸ“Š XP potÅ™ebnÃ© pro level",
        value="**Lvl 2:** 100 XP\n"
              "**Lvl 3:** 400 XP\n"
              "**Lvl 5:** 1,600 XP\n"
              "**Lvl 10:** 8,100 XP\n"
              "**Lvl 15:** 19,600 XP\n"
              "**Lvl 20:** 36,100 XP\n"
              "**Lvl 25:** 57,600 XP\n"
              "**Lvl 30:** 84,100 XP",
        inline=True
    )
    
    level_embed.add_field(
        name="ğŸ’¡ TIPY",
        value="â€¢ Hraj kvÃ­zy kaÅ¾dÃ½ den pro rychlÃ© XP\n"
              "â€¢ NezapomeÅˆ na `/daily` bonus\n"
              "â€¢ Hraj hry na PC pro pasivnÃ­ XP\n"
              "â€¢ PlÅˆ Ãºkoly pro velkÃ© bonusy",
        inline=False
    )
    
    level_embed.set_footer(text="âš”ï¸ Valhalla Bot â€¢ Hraj, sbÃ­rej XP a staÅˆ se legendou!")
    
    # OdeslÃ¡nÃ­ vÅ¡ech embedÅ¯ do cÃ­lovÃ©ho kanÃ¡lu (trvalÃ© zprÃ¡vy)
    await target_channel.send(embed=main_embed)
    await target_channel.send(embed=xp_embed)
    await target_channel.send(embed=level_embed)
    
    # PotvrzenÃ­ v pÅ¯vodnÃ­m kanÃ¡lu
    await ctx.send(f"âœ… HernÃ­ info bylo odeslÃ¡no do kanÃ¡lu <#{GAME_NOTIFICATION_CHANNEL}>!", delete_after=10)

@send_game_info.error
async def send_game_info_error(ctx, error):
    if isinstance(error, commands.MissingPermissions):
        await ctx.send("âŒ Tento pÅ™Ã­kaz mÅ¯Å¾e pouÅ¾Ã­t pouze administrÃ¡tor!", delete_after=10)
    else:
        print(f"[ERROR] herniinfo: {error}", flush=True)
        await ctx.send(f"âŒ Nastala chyba: {error}", delete_after=10)

# ============== GAME LEVEL SYSTEM ==============

LEVEL_BADGES = {
    1: "ğŸŒ±", 2: "ğŸŒ¿", 3: "ğŸŒ³", 4: "â­", 5: "ğŸŒŸ",
    10: "ğŸ’«", 15: "ğŸ”¥", 20: "ğŸ’", 25: "ğŸ‘‘", 30: "ğŸ†",
    40: "ğŸ¯", 50: "ğŸš€", 75: "ğŸŒˆ", 100: "ğŸ…"
}

def get_badge(level: int) -> str:
    """Get badge for level"""
    badge = "ğŸŒ±"
    for lvl, b in sorted(LEVEL_BADGES.items()):
        if level >= lvl:
            badge = b
    return badge

def create_progress_bar(current: int, total: int, length: int = 10) -> str:
    """Create a visual progress bar"""
    if total == 0:
        return "â–“" * length
    filled = int((current / total) * length)
    empty = length - filled
    return "â–“" * filled + "â–‘" * empty

@bot.tree.command(name="gamelevel", description="Zobraz svÅ¯j hernÃ­ level a statistiky")
async def slash_gamelevel(interaction: discord.Interaction, hrac: discord.Member = None):
    # Check permission from database
    if not await check_command_permission(interaction, "gamelevel"):
        return
    
    target = hrac or interaction.user
    user_data = get_user_data(interaction.guild_id, target.id)
    
    level = calculate_level(user_data["xp"])
    current_level_xp = xp_for_level(level)
    next_level_xp = xp_for_level(level + 1)
    xp_progress = user_data["xp"] - current_level_xp
    xp_needed = next_level_xp - current_level_xp
    
    badge = get_badge(level)
    progress_bar = create_progress_bar(xp_progress, xp_needed, 12)
    
    # PÅ™esnost kvÃ­zÅ¯
    accuracy = 0
    if user_data.get("total_games", 0) > 0:
        accuracy = (user_data.get("total_correct", 0) / user_data["total_games"]) * 100
    
    # HernÃ­ statistiky
    unlocked_games = user_data.get("unlocked_games", [])
    total_game_time = user_data.get("total_game_time", 0)
    game_times = user_data.get("game_times", {})
    
    # FormÃ¡tovÃ¡nÃ­ Äasu
    hours = total_game_time // 60
    minutes = total_game_time % 60
    time_str = f"{hours}h {minutes}m" if hours > 0 else f"{minutes}m"
    
    embed = discord.Embed(
        title=f"{badge} {target.display_name}",
        color=discord.Color.purple()
    )
    embed.set_thumbnail(url=target.display_avatar.url)
    
    # ZÃ¡kladnÃ­ statistiky
    embed.add_field(
        name="ğŸ“Š Level",
        value=f"**Level {level}**",
        inline=True
    )
    embed.add_field(
        name="âœ¨ XP",
        value=f"**{user_data['xp']:,}** XP",
        inline=True
    )
    embed.add_field(
        name="ğŸ”¥ Streak",
        value=f"**{user_data.get('streak', 0)}** dnÅ¯",
        inline=True
    )
    
    # Progress bar
    embed.add_field(
        name=f"ğŸ“ˆ Progress ({xp_progress:,}/{xp_needed:,} XP)",
        value=f"`{progress_bar}`",
        inline=False
    )
    
    # KvÃ­zovÃ© statistiky
    embed.add_field(
        name="ğŸ® KvÃ­zÅ¯",
        value=f"**{user_data.get('total_games', 0)}**",
        inline=True
    )
    embed.add_field(
        name="âœ… SprÃ¡vnÄ›",
        value=f"**{user_data.get('total_correct', 0)}**",
        inline=True
    )
    embed.add_field(
        name="ğŸ¯ PÅ™esnost",
        value=f"**{accuracy:.1f}%**",
        inline=True
    )
    
    # HernÃ­ statistiky (PC hry)
    embed.add_field(
        name="ğŸ•¹ï¸ OdemÄenÃ© hry",
        value=f"**{len(unlocked_games)}** her",
        inline=True
    )
    embed.add_field(
        name="â±ï¸ ÄŒas hranÃ­",
        value=f"**{time_str}**",
        inline=True
    )
    embed.add_field(
        name="ğŸ“… DennÃ­ XP",
        value=f"**{user_data.get('daily_game_xp', 0)}/{GAME_XP_DAILY_LIMIT}**",
        inline=True
    )
    
    # Top 3 nejhranÄ›jÅ¡Ã­ hry
    if game_times:
        sorted_games = sorted(game_times.items(), key=lambda x: x[1], reverse=True)[:3]
        top_games = []
        for game, mins in sorted_games:
            g_hours = mins // 60
            g_mins = mins % 60
            g_time = f"{g_hours}h {g_mins}m" if g_hours > 0 else f"{g_mins}m"
            top_games.append(f"â€¢ **{game}**: {g_time}")
        
        if top_games:
            embed.add_field(
                name="ğŸ® NejhranÄ›jÅ¡Ã­ hry",
                value="\n".join(top_games),
                inline=False
            )
    
    embed.set_footer(text="âš”ï¸ Valhalla Bot â€¢ /hry pro vÅ¡echny hry â€¢ /ukoly pro Ãºkoly")
    
    await interaction.response.send_message(embed=embed)
    msg = await interaction.original_response()
    asyncio.create_task(delete_after(msg, 60))

@bot.command(name="level", aliases=["lvl", "gamelevel", "rank", "xp"])
async def prefix_gamelevel(ctx, hrac: discord.Member = None):
    """!level - Zobraz svÅ¯j level"""
    target = hrac or ctx.author
    user_data = get_user_data(ctx.guild.id, target.id)
    
    level = calculate_level(user_data["xp"])
    current_level_xp = xp_for_level(level)
    next_level_xp = xp_for_level(level + 1)
    xp_progress = user_data["xp"] - current_level_xp
    xp_needed = next_level_xp - current_level_xp
    
    badge = get_badge(level)
    progress_bar = create_progress_bar(xp_progress, xp_needed, 12)
    
    # PÅ™esnost kvÃ­zÅ¯
    accuracy = 0
    if user_data.get("total_games", 0) > 0:
        accuracy = (user_data.get("total_correct", 0) / user_data["total_games"]) * 100
    
    # HernÃ­ statistiky
    unlocked_games = user_data.get("unlocked_games", [])
    total_game_time = user_data.get("total_game_time", 0)
    game_times = user_data.get("game_times", {})
    
    # FormÃ¡tovÃ¡nÃ­ Äasu
    hours = total_game_time // 60
    minutes = total_game_time % 60
    time_str = f"{hours}h {minutes}m" if hours > 0 else f"{minutes}m"
    
    embed = discord.Embed(
        title=f"{badge} {target.display_name}",
        color=discord.Color.purple()
    )
    embed.set_thumbnail(url=target.display_avatar.url)
    
    # ZÃ¡kladnÃ­ statistiky
    embed.add_field(name="ğŸ“Š Level", value=f"**Level {level}**", inline=True)
    embed.add_field(name="âœ¨ XP", value=f"**{user_data['xp']:,}** XP", inline=True)
    embed.add_field(name="ğŸ”¥ Streak", value=f"**{user_data.get('streak', 0)}** dnÅ¯", inline=True)
    
    embed.add_field(name=f"ğŸ“ˆ Progress ({xp