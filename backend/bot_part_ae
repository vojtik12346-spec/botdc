": "vÄ›da"},
    {"fact": "VelkÃ¡ ÄÃ­nskÃ¡ zeÄ je vidÄ›t z vesmÃ­ru pouhÃ½m okem", "answer": False, "category": "vÄ›da"},
    {"fact": "Diamant lze zniÄit ohnÄ›m", "answer": True, "category": "vÄ›da"},
    {"fact": "HorkÃ¡ voda zamrzÃ¡ rychleji neÅ¾ studenÃ¡", "answer": True, "category": "vÄ›da"},
    {"fact": "SevernÃ­ pÃ³l mÃ¡ pevninu pod ledem", "answer": False, "category": "vÄ›da"},
    {"fact": "Saturn by plaval ve vodÄ›, kdyby byla dostateÄnÄ› velkÃ¡ nÃ¡doba", "answer": True, "category": "vÄ›da"},
    {"fact": "Na Marsu jsou sopky vÄ›tÅ¡Ã­ neÅ¾ Mount Everest", "answer": True, "category": "vÄ›da"},
    {"fact": "ÄŒlovÄ›k mÅ¯Å¾e pÅ™eÅ¾Ã­t ve vesmÃ­ru 2 minuty bez skafandru", "answer": False, "category": "vÄ›da"},
    
    # Historie
    {"fact": "Kleopatra Å¾ila blÃ­Å¾e k pÅ™istÃ¡nÃ­ na MÄ›sÃ­ci neÅ¾ ke stavbÄ› pyramid", "answer": True, "category": "historie"},
    {"fact": "VikingovÃ© nosili rohatÃ© helmy", "answer": False, "category": "historie"},
    {"fact": "Napoleon byl velmi malÃ½", "answer": False, "category": "historie"},
    {"fact": "Oxford univerzita je starÅ¡Ã­ neÅ¾ AztÃ©ckÃ¡ Å™Ã­Å¡e", "answer": True, "category": "historie"},
    {"fact": "Albert Einstein propadl z matematiky", "answer": False, "category": "historie"},
    {"fact": "Ve starovÄ›kÃ©m Å˜Ã­mÄ› existovala bohynÄ› kanalizace", "answer": True, "category": "historie"},
    {"fact": "Pyramidy byly pÅ¯vodnÄ› bÃ­lÃ© a lesklÃ©", "answer": True, "category": "historie"},
    {"fact": "PoslednÃ­ poprava gilotinou ve Francii byla v roce 1977", "answer": True, "category": "historie"},
    {"fact": "Coca-Cola byla pÅ¯vodnÄ› zelenÃ¡", "answer": False, "category": "historie"},
    {"fact": "Titanic byl prvnÃ­ loÄ, kterÃ¡ pouÅ¾ila SOS signÃ¡l", "answer": False, "category": "historie"},
    {"fact": "ÄŒeskÃ¡ republika mÃ¡ vÃ­ce hradÅ¯ na kmÂ² neÅ¾ jakÃ¡koli jinÃ¡ zemÄ›", "answer": True, "category": "historie"},
    {"fact": "PrvnÃ­ programÃ¡tor na svÄ›tÄ› byla Å¾ena", "answer": True, "category": "historie"},
    {"fact": "Edison vynalezl Å¾Ã¡rovku", "answer": False, "category": "historie"},
    {"fact": "ÄŒÃ­nskÃ¡ zeÄ je vidÄ›t z MÄ›sÃ­ce", "answer": False, "category": "historie"},
    
    # LidskÃ© tÄ›lo
    {"fact": "LidskÃ½ nos dokÃ¡Å¾e rozpoznat bilion rÅ¯znÃ½ch vÅ¯nÃ­", "answer": True, "category": "tÄ›lo"},
    {"fact": "Nehty na rukou rostou rychleji neÅ¾ na nohou", "answer": True, "category": "tÄ›lo"},
    {"fact": "Å½aludek vytvÃ¡Å™Ã­ novou vÃ½stelku kaÅ¾dÃ© 3-4 dny", "answer": True, "category": "tÄ›lo"},
    {"fact": "ÄŒlovÄ›k mÃ¡ vÃ­c neÅ¾ 5 smyslÅ¯", "answer": True, "category": "tÄ›lo"},
    {"fact": "Krev je modrÃ¡, dokud se nedostane do kontaktu s kyslÃ­kem", "answer": False, "category": "tÄ›lo"},
    {"fact": "Vlasy rostou po smrti", "answer": False, "category": "tÄ›lo"},
    {"fact": "Jazyk je nejsilnÄ›jÅ¡Ã­ sval v tÄ›le", "answer": False, "category": "tÄ›lo"},
    {"fact": "LidÃ© majÃ­ unikÃ¡tnÃ­ otisk jazyka, jako otisky prstÅ¯", "answer": True, "category": "tÄ›lo"},
    {"fact": "DospÄ›lÃ½ ÄlovÄ›k mÃ¡ 206 kostÃ­", "answer": True, "category": "tÄ›lo"},
    {"fact": "Novorozenec mÃ¡ vÃ­ce kostÃ­ neÅ¾ dospÄ›lÃ½", "answer": True, "category": "tÄ›lo"},
    {"fact": "Mozek necÃ­tÃ­ bolest", "answer": True, "category": "tÄ›lo"},
    {"fact": "ÄŒlovÄ›k dennÄ› vytvoÅ™Ã­ 1-2 litry slin", "answer": True, "category": "tÄ›lo"},
    {"fact": "Srdce bije i mimo tÄ›lo", "answer": True, "category": "tÄ›lo"},
    {"fact": "ÄŒlovÄ›k se rodÃ­ bez kolenÃ­ch ÄÃ©Å¡ek", "answer": True, "category": "tÄ›lo"},
    
    # JÃ­dlo
    {"fact": "Med nikdy nezkazÃ­", "answer": True, "category": "jÃ­dlo"},
    {"fact": "RajÄata jsou ovoce", "answer": True, "category": "jÃ­dlo"},
    {"fact": "Jahody nejsou bobule, ale banÃ¡ny ano", "answer": True, "category": "jÃ­dlo"},
    {"fact": "AraÅ¡Ã­dy jsou oÅ™echy", "answer": False, "category": "jÃ­dlo"},
    {"fact": "Wasabi, kterÃ© dostanete v restauraci, je obvykle kÅ™en s barvivem", "answer": True, "category": "jÃ­dlo"},
    {"fact": "BÃ­lÃ¡ ÄokolÃ¡da obsahuje ÄokolÃ¡du", "answer": False, "category": "jÃ­dlo"},
    {"fact": "KeÄup byl kdysi prodÃ¡vÃ¡n jako lÃ©k", "answer": True, "category": "jÃ­dlo"},
    {"fact": "MuÅ¡kÃ¡tovÃ½ oÅ™Ã­Å¡ek ve velkÃ©m mnoÅ¾stvÃ­ zpÅ¯sobuje halucinace", "answer": True, "category": "jÃ­dlo"},
    {"fact": "AvokÃ¡do je ovoce", "answer": True, "category": "jÃ­dlo"},
    {"fact": "PomeranÄe se jmenujÃ­ podle barvy", "answer": False, "category": "jÃ­dlo"},
    {"fact": "PÃ¡livost chilli papriÄek se mÄ›Å™Ã­ ve Scoville jednotkÃ¡ch", "answer": True, "category": "jÃ­dlo"},
    {"fact": "Brambory majÃ­ vÃ­ce chromozomÅ¯ neÅ¾ ÄlovÄ›k", "answer": True, "category": "jÃ­dlo"},
    
    # ÄŒesko
    {"fact": "Praha je starÅ¡Ã­ neÅ¾ VÃ­deÅˆ", "answer": True, "category": "Äesko"},
    {"fact": "ÄŒeÅ¡i pijÃ­ nejvÃ­ce piva na svÄ›tÄ› na osobu", "answer": True, "category": "Äesko"},
    {"fact": "Slovo robot vymyslel Karel ÄŒapek", "answer": False, "category": "Äesko"},
    {"fact": "KontaktnÃ­ ÄoÄky vynalezl ÄŒech", "answer": True, "category": "Äesko"},
    {"fact": "ÄŒeskÃ¡ republika nemÃ¡ moÅ™e", "answer": True, "category": "Äesko"},
    {"fact": "KarlÅ¯v most byl postaven za vlÃ¡dy Karla IV.", "answer": True, "category": "Äesko"},
    {"fact": "Semtex byl vynalezen v ÄŒesku", "answer": True, "category": "Äesko"},
    {"fact": "Kostka cukru byla vynalezena v ÄŒesku", "answer": True, "category": "Äesko"},
    {"fact": "VÃ¡clavskÃ© nÃ¡mÄ›stÃ­ je ve skuteÄnosti bulvÃ¡r, ne nÃ¡mÄ›stÃ­", "answer": True, "category": "Äesko"},
    {"fact": "ÄŒeskÃ¡ hymna mÃ¡ jen jednu sloku", "answer": True, "category": "Äesko"},
    {"fact": "PraÅ¾skÃ½ orloj je nejstarÅ¡Ã­ fungujÃ­cÃ­ astronomickÃ© hodiny na svÄ›tÄ›", "answer": True, "category": "Äesko"},
    {"fact": "Slovo dolar pochÃ¡zÃ­ z ÄeskÃ©ho tolaru", "answer": True, "category": "Äesko"},
    
    # ZÃ¡bavnÃ©/BizarnÃ­
    {"fact": "V Japonsku existuje ostrov plnÃ½ krÃ¡lÃ­kÅ¯", "answer": True, "category": "bizarnÃ­"},
    {"fact": "Ve Å vÃ½carsku je nelegÃ¡lnÃ­ mÃ­t jen jednoho morÄete", "answer": True, "category": "bizarnÃ­"},
    {"fact": "Kachny kvÃ¡kÃ¡nÃ­ nevytvÃ¡Å™Ã­ ozvÄ›nu", "answer": False, "category": "bizarnÃ­"},
    {"fact": "McDonald's prodÃ¡vÃ¡ v Indii hovÄ›zÃ­ burgery", "answer": False, "category": "bizarnÃ­"},
    {"fact": "LEGO vyrÃ¡bÃ­ vÃ­ce pneumatik roÄnÄ› neÅ¾ jakÃ¡koli jinÃ¡ firma", "answer": True, "category": "bizarnÃ­"},
    {"fact": "Twitter logo ptÃ¡Äek se jmenuje Larry", "answer": True, "category": "bizarnÃ­"},
    {"fact": "Barbie mÃ¡ pÅ™Ã­jmenÃ­ Roberts", "answer": True, "category": "bizarnÃ­"},
    {"fact": "V angliÄtinÄ› existuje slovo pro strach z dlouhÃ½ch slov", "answer": True, "category": "bizarnÃ­"},
    {"fact": "Jazykolam je hippopotomonstrosesquipedaliofÃ³bie", "answer": True, "category": "bizarnÃ­"},
    {"fact": "Nintendo bylo zaloÅ¾eno v roce 1889", "answer": True, "category": "bizarnÃ­"},
    {"fact": "PrÅ¯mÄ›rnÃ½ ÄlovÄ›k snÃ­ za Å¾ivot 8 pavoukÅ¯ ve spÃ¡nku", "answer": False, "category": "bizarnÃ­"},
    {"fact": "V Norsku existuje mÄ›sto s nÃ¡zvem Hell", "answer": True, "category": "bizarnÃ­"},
    {"fact": "KeÄup teÄe rychlostÃ­ 40 km za hodinu", "answer": False, "category": "bizarnÃ­"},
    {"fact": "Emoji pro tvÃ¡Å™ s potem ğŸ˜… pÅ¯vodnÄ› znamenalo Ãºlevu, ne nervozitu", "answer": True, "category": "bizarnÃ­"},
]

# Active pravda/leÅ¾ games
active_truth_games = {}

class TruthView(discord.ui.View):
    def __init__(self, channel_id: int, correct_answer: bool, fact_text: str):
        super().__init__(timeout=30)
        self.channel_id = channel_id
        self.correct_answer = correct_answer
        self.fact_text = fact_text
        self.answered_users = {}  # {user_id: {"name": name, "answer": bool}}
    
    @discord.ui.button(label="âœ… PRAVDA", style=discord.ButtonStyle.success, custom_id="truth_true")
    async def truth_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.handle_answer(interaction, True)
    
    @discord.ui.button(label="âŒ LEÅ½", style=discord.ButtonStyle.danger, custom_id="truth_false")
    async def lie_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.handle_answer(interaction, False)
    
    async def handle_answer(self, interaction: discord.Interaction, user_answer: bool):
        user_id = interaction.user.id
        
        if user_id in self.answered_users:
            await interaction.response.send_message("âŒ UÅ¾ jsi odpovÄ›dÄ›l/a!", ephemeral=True)
            return
        
        self.answered_users[user_id] = {
            "name": interaction.user.display_name,
            "answer": user_answer
        }
        
        is_correct = user_answer == self.correct_answer
        
        if is_correct:
            await interaction.response.send_message("âœ… SprÃ¡vnÄ›! PoÄkej na vÃ½sledky...", ephemeral=True)
        else:
            await interaction.response.send_message("âŒ Å patnÄ›! PoÄkej na vÃ½sledky...", ephemeral=True)
    
    async def on_timeout(self):
        # This is handled by the game loop
        pass

async def run_truth_game(channel, message, view: TruthView, fact_data: dict, guild_id: int):
    """Wait for answers and show results"""
    await asyncio.sleep(15)  # Wait 15 seconds for answers
    
    # Disable buttons
    for item in view.children:
        item.disabled = True
    
    # Count results and give XP
    correct_users = []
    wrong_users = []
    
    for user_id, data in view.answered_users.items():
        if data["answer"] == view.correct_answer:
            correct_users.append(data["name"])
            # Add XP for correct answer
            await add_xp(guild_id, user_id, data["name"], XP_REWARDS["truth_correct"], channel)
            increment_stats(guild_id, user_id, correct=True)
        else:
            wrong_users.append(data["name"])
            increment_stats(guild_id, user_id, correct=False)
    
    answer_text = "âœ… PRAVDA" if view.correct_answer else "âŒ LEÅ½"
    
    embed = discord.Embed(
        title="ğŸ¯ VÃSLEDKY",
        description=f"**{view.fact_text}**",
        color=discord.Color.green() if view.correct_answer else discord.Color.red()
    )
    embed.add_field(name="SprÃ¡vnÃ¡ odpovÄ›Ä", value=answer_text, inline=False)
    
    if correct_users:
        embed.add_field(name=f"âœ… SprÃ¡vnÄ› ({len(correct_users)}) +{XP_REWARDS['truth_correct']} XP", value=", ".join(correct_users[:15]) or "Nikdo", inline=True)
    if wrong_users:
        embed.add_field(name=f"âŒ Å patnÄ› ({len(wrong_users)})", value=", ".join(wrong_users[:15]) or "Nikdo", inline=True)
    
    if not view.answered_users:
        embed.add_field(name="ğŸ˜¢", value="Nikdo neodpovÄ›dÄ›l!", inline=False)
    
    embed.set_footer(text=f"Kategorie: {fact_data.get('category', 'obecnÃ©')}")
    
    try:
        await message.edit(embed=embed, view=view)
    except:
        pass
    
    # Cleanup
    if channel.id in active_truth_games:
        del active_truth_games[channel.id]

@bot.tree.command(name="pravda", description="Pravda nebo leÅ¾? HÃ¡dej jestli je fakt pravdivÃ½!")
@app_commands.describe(kategorie="Vyber kategorii faktÅ¯")
@app_commands.choices(kategorie=[
    app_commands.Choice(name="ğŸ¾ ZvÃ­Å™ata", value="zvÃ­Å™ata"),
    app_commands.Choice(name="ğŸ”¬ VÄ›da", value="vÄ›da"),
    app_commands.Choice(name="ğŸ“œ Historie", value="historie"),
    app_commands.Choice(name="ğŸ«€ LidskÃ© tÄ›lo", value="tÄ›lo"),
    app_commands.Choice(name="ğŸ• JÃ­dlo", value="jÃ­dlo"),
    app_commands.Choice(name="ğŸ‡¨ğŸ‡¿ ÄŒesko", value="Äesko"),
    app_commands.Choice(name="ğŸ¤ª BizarnÃ­", value="bizarnÃ­"),
    app_commands.Choice(name="ğŸ² NÃ¡hodnÃ©", value="random"),
])
async def slash_pravda(interaction: discord.Interaction, kategorie: str = "random"):
    # Check permission from database
    if not await check_command_permission(interaction, "pravda"):
        return
    
    import random
    
    channel_id = interaction.channel_id
    
    if channel_id in active_truth_games:
        await interaction.response.send_message("âŒ V tomto kanÃ¡lu uÅ¾ bÄ›Å¾Ã­ hra! PoÄkej na vÃ½sledky.", ephemeral=True)
        return
    
    # Filter facts by category
    if kategorie == "random":
        available_facts = FACTS_DATABASE
    else:
        available_facts = [f for f in FACTS_DATABASE if f.get("category") == kategorie]
    
    if not available_facts:
        available_facts = FACTS_DATABASE
    
    fact_data = random.choice(available_facts)
    
    active_truth_games[channel_id] = True
    
    view = TruthView(channel_id, fact_data["answer"], fact_data["fact"])
    
    category_names = {
        "zvÃ­Å™ata": "ğŸ¾ ZvÃ­Å™ata", "vÄ›da": "ğŸ”¬ VÄ›da", "historie": "ğŸ“œ Historie",
        "tÄ›lo": "ğŸ«€ LidskÃ© tÄ›lo", "jÃ­dlo": "ğŸ• JÃ­dlo", "Äesko": "ğŸ‡¨ğŸ‡¿ ÄŒesko",
        "bizarnÃ­": "ğŸ¤ª BizarnÃ­"
    }
    
    embed = discord.Embed(
        title="ğŸ¤” PRAVDA NEBO LEÅ½?",
        description=f"**{fact_data['fact']}**",
        color=discord.Color.blue()
    )
    embed.add_field(name="ğŸ“ Kategorie", value=category_names.get(fact_data.get("category"), "ObecnÃ©"), inline=True)
    embed.add_field(name="â° ÄŒas", value="15 sekund", inline=True)
    embed.set_footer(text="Klikni na tlaÄÃ­tko pro odpovÄ›Ä!")
    
    await interaction.response.send_message(embed=embed, view=view)
    message = await interaction.original_response()
    
    # Start game loop
    asyncio.create_task(run_truth_game(interaction.channel, message, view, fact_data, interaction.guild_id))

@bot.command(name="pravda", aliases=["pn", "fact", "fakt"])
async def prefix_pravda(ctx, kategorie: str = "random"):
    """!pravda [kategorie] - Pravda nebo leÅ¾ hra"""
    import random
    
    channel_id = ctx.channel.id
    
    if channel_id in active_truth_games:
        await ctx.send("âŒ V tomto kanÃ¡lu uÅ¾ bÄ›Å¾Ã­ hra! PoÄkej na vÃ½sledky.")
        return
    
    # Map category aliases
    category_map = {
        "zvirata": "zvÃ­Å™ata", "zvÃ­Å™ata": "zvÃ­Å™ata", "animals": "zvÃ­Å™ata",
        "veda": "vÄ›da", "vÄ›da": "vÄ›da", "science": "vÄ›da",
        "historie": "historie", "history": "historie",
        "telo": "tÄ›lo", "tÄ›lo": "tÄ›lo", "body": "tÄ›lo",
        "jidlo": "jÃ­dlo", "jÃ­dlo": "jÃ­dlo", "food": "jÃ­dlo",
        "cesko": "Äesko", "Äesko": "Äesko", "cz": "Äesko",
        "bizarni": "bizarnÃ­", "bizarnÃ­": "bizarnÃ­", "weird": "bizarnÃ­",
        "random": "random", "nahodne": "random"
    }
    
    kategorie = category_map.get(kategorie.lower(), "random")
    
    if kategorie == "random":
        available_facts = FACTS_DATABASE
    else:
        available_facts = [f for f in FACTS_DATABASE if f.get("category") == kategorie]
    
    if not available_facts:
        available_facts = FACTS_DATABASE
    
    fact_data = random.choice(available_facts)
    
    active_truth_games[channel_id] = True
    
    view = TruthView(channel_id, fact_data["answer"], fact_data["fact"])
    
    category_names = {
        "zvÃ­Å™ata": "ğŸ¾ ZvÃ­Å™ata", "vÄ›da": "ğŸ”¬ VÄ›da", "historie": "ğŸ“œ Historie",
        "tÄ›lo": "ğŸ«€ LidskÃ© tÄ›lo", "jÃ­dlo": "ğŸ• JÃ­dlo", "Äesko": "ğŸ‡¨ğŸ‡¿ ÄŒesko",
        "bizarnÃ­": "ğŸ¤ª BizarnÃ­"
    }
    
    embed = discord.Embed(
        title="ğŸ¤” PRAVDA NEBO LEÅ½?",
        description=f"**{fact_data['fact']}**",
        color=discord.Color.blue()
    )
    embed.add_field(name="ğŸ“ Kategorie", value=category_names.get(fact_data.get("category"), "ObecnÃ©"), inline=True)
    embed.add_field(name="â° ÄŒas", value="15 sekund", inline=True)
    embed.set_footer(text="Klikni na tlaÄÃ­tko pro odpovÄ›Ä!")
    
    message = await ctx.send(embed=embed, view=view)
    
    asyncio.create_task(run_truth_game(ctx.channel, message, view, fact_data, ctx.guild.id))

# Active film quizzes
active_film_quiz = {}

@bot.tree.command(name="film", description="SpusÅ¥ filmovÃ½ kvÃ­z - hÃ¡dej film!")
@app_commands.describe(zanr="Vyber Å¾Ã¡nr filmÅ¯")
@app_commands.choices(zanr=[
    app_commands.Choice(name="ğŸ‡¨ğŸ‡¿ ÄŒeskÃ© filmy", value="ceske"),
    app_commands.Choice(name="ğŸ¬ Hollywood", value="hollywood"),
    app_commands.Choice(name="ğŸ˜‚ Komedie", value="komedie"),
    app_commands.Choice(name="ğŸ’¥ AkÄnÃ­", value="akcni"),
    app_commands.Choice(name="ğŸ‘» Horor", value="horor"),
    app_commands.Choice(name="ğŸš€ Sci-Fi", value="scifi"),
    app_commands.Choice(name="ğŸ² NÃ¡hodnÃ½", value="random"),
])
async def slash_film(interaction: discord.Interaction, zanr: str = "random"):
    # Check permission from database
    if not await check_command_permission(interaction, "film"):
        return
    
    channel_id = interaction.channel_id
    guild_id = interaction.guild_id
    
    if channel_id in active_film_quiz and active_film_quiz[channel_id].get("active"):
        await interaction.response.send_message("âŒ V tomto kanÃ¡lu uÅ¾ bÄ›Å¾Ã­ filmovÃ½ kvÃ­z!", ephemeral=True)
        return
    
    quiz_time = get_quiz_time(guild_id)
    total_rounds = get_quiz_rounds(guild_id)
    
    active_film_quiz[channel_id] = {
        "active": True,
        "genre": zanr,
        "current_round": 0,
        "total_rounds": total_rounds,
        "scores": {},
        "current_question": None,
        "answered": False,
        "quiz_time": quiz_time,
        "guild_id": guild_id
    }
    
    genre_names = {"ceske": "ğŸ‡¨ğŸ‡¿ ÄŒeskÃ©", "hollywood": "ğŸ¬ Hollywood", "komedie": "ğŸ˜‚ Komedie", "akcni": "ğŸ’¥ AkÄnÃ­", "horor": "ğŸ‘» Horor", "scifi": "ğŸš€ Sci-Fi"}
    
    embed = discord.Embed(
        title="ğŸ¬ FILMOVÃ KVÃZ ZAÄŒÃNÃ!",
        description=f"**{total_rounds} otÃ¡zek** | **{quiz_time}s na odpovÄ›Ä**",
        color=discord.Color.red()
    )
    embed.add_field(name="ğŸï¸ Å½Ã¡nr", value=genre_names.get(zanr, "NÃHODNÃ"), inline=True)
    embed.add_field(name="ğŸ“ Pravidla", value="NapiÅ¡ nÃ¡zev filmu do chatu!", inline=False)
    embed.set_footer(text="PrvnÃ­ otÃ¡zka za 3 sekundy...")
    
    await interaction.response.send_message(embed=embed)
    await asyncio.sleep(3)
    
    await run_film_quiz(interaction.channel, channel_id)

async def run_film_quiz(channel, channel_id: int):
    """Run multiple rounds of film quiz"""
    import random
    
    quiz_data = active_film_quiz.get(channel_id)
    if not quiz_data:
        return
    
    genre = quiz_data["genre"]
    total_rounds = quiz_data["total_rounds"]
    quiz_time = quiz_data["quiz_time"]
    genre_names = {"ceske": "ğŸ‡¨ğŸ‡¿ ÄŒeskÃ©", "hollywood": "ğŸ¬ Hollywood", "komedie": "ğŸ˜‚ Komedie", "akcni": "ğŸ’¥ AkÄnÃ­", "horor": "ğŸ‘» Horor", "scifi": "ğŸš€ Sci-Fi"}
    
    for round_num in range(1, total_rounds + 1):
        if channel_id not in active_film_quiz:
            return
        
        quiz_data = active_film_quiz[channel_id]
        quiz_data["current_round"] = round_num
        quiz_data["answered"] = False
        
        current_genre = genre if genre != "random" else random.choice(list(FILM_DATABASE.keys()))
        film_data = random.choice(FILM_DATABASE[current_genre])
        
        quiz_data["current_question"] = {
            "film": film_data["film"],
            "year": film_data["year"],
            "hint": film_data["hint"]
        }
        
        embed = discord.Embed(
            title=f"ğŸ¬ OTÃZKA {round_num}/{total_rounds}",
            description="**HÃ¡dej film!**",
            color=discord.Color.red()
        )
        embed.add_field(name="ğŸ¤ SlavnÃ¡ hlÃ¡Å¡ka", value=f"*\"{film_data['quote']}\"*", inline=False)
        embed.add_field(name="ğŸ’¡ NÃ¡povÄ›da", value=f"`{film_data['hint']}`", inline=True)
        embed.add_field(name="ğŸ“… Rok", value=film_data['year'], inline=True)
        embed.add_field(name="ğŸï¸ Å½Ã¡nr", value=genre_names.get(current_genre, current_genre), inline=True)
        embed.add_field(name="â° ÄŒas", value=f"{quiz_time}s", inline=True)
        
        await channel.send(embed=embed)
        
        elapsed = 0
        while elapsed < quiz_time:
            await asyncio.sleep(0.5)
            elapsed += 0.5
            
            quiz_data = active_film_quiz.get(channel_id)
            if not quiz_data:
                return
            if quiz_data.get("answered"):
                break
        
        quiz_data = active_film_quiz.get(channel_id)
        if not quiz_data:
            return
        
        if not quiz_data["answered"]:
            embed = discord.Embed(
                title="â° ÄŒAS VYPRÅ EL!",
                description=f"SprÃ¡vnÃ¡ odpovÄ›Ä: **{film_data['film']}** ({film_data['year']})",
                color=discord.Color.orange()
            )
            await channel.send(embed=embed)
        
        if round_num < total_rounds:
            await channel.send(f"â³ **DalÅ¡Ã­ otÃ¡zka za 3 sekundy...**")
            await asyncio.sleep(3)
    
    # Quiz finished
    quiz_data = active_film_quiz.get(channel_id)
    if quiz_data:
        scores = quiz_data.get("scores", {})
        
        if scores:
            sorted_scores = sorted(scores.items(), key=lambda x: x[1]["score"], reverse=True)
            
            medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"]
            leaderboard = ""
            for i, (user_id, data) in enumerate(sorted_scores[:10]):
                medal = medals[i] if i < 3 else f"**{i+1}.**"
                leaderboard += f"{medal} {data['name']} - **{data['score']} bodÅ¯**\n"
            
            embed = discord.Embed(
                title="ğŸ† FILMOVÃ KVÃZ DOKONÄŒEN!",
                description=f"**VÃ½sledky z {total_rounds} otÃ¡zek:**",
                color=discord.Color.gold()
            )
            embed.add_field(name="ğŸ“Š Å½ebÅ™Ã­Äek", value=leaderboard or "Nikdo neskÃ³roval", inline=False)
            
            if sorted_scores:
                winner_id, winner_data = sorted_scores[0]
                embed.add_field(name="ğŸ‘‘ VÃ­tÄ›z", value=f"**{winner_data['name']}** s {winner_data['score']} body!", inline=False)
        else:
            embed = discord.Embed(
                title="ğŸ† FILMOVÃ KVÃZ DOKONÄŒEN!",
                description="Nikdo neuhodl Å¾Ã¡dnou otÃ¡zku!",
                color=discord.Color.orange()
            )
        
        await channel.send(embed=embed)
        
        if channel_id in active_film_quiz:
            del active_film_quiz[channel_id]

@bot.command(name="film", aliases=["movie", "kino"])
@commands.has_permissions(administrator=True)
async def prefix_film(ctx, zanr: str = "random"):
    """!film [ceske/hollywood/komedie/akcni/horor/scifi/random] - FilmovÃ½ kvÃ­z (Admin)"""
    channel_id = ctx.channel.id
    guild_id = ctx.guild.id
    
    if channel_id in active_film_quiz and active_film_quiz[channel_id].get("active"):
        await ctx.send("âŒ V tomto kanÃ¡lu uÅ¾ bÄ›Å¾Ã­ filmovÃ½ kvÃ­z!")
        return
    
    if zanr not in ["ceske", "hollywood", "komedie", "akcni", "horor", "scifi", "random"]:
        zanr = "random"
    
    quiz_time = get_quiz_time(guild_id)
    total_rounds = get_quiz_rounds(guild_id)
    
    active_film_quiz[channel_id] = {
        "active": True,
        "genre": zanr,
        "current_round": 0,
        "total_rounds": total_rounds,
        "scores": {},
        "current_question": None,
        "answered": False,
        "quiz_time": quiz_time,
        "guild_id": guild_id
    }
    
    genre_names = {"ceske": "ğŸ‡¨ğŸ‡¿ ÄŒeskÃ©", "hollywood": "ğŸ¬ Hollywood", "komedie": "ğŸ˜‚ Komedie", "akcni": "ğŸ’¥ AkÄnÃ­", "horor": "ğŸ‘» Horor", "scifi": "ğŸš€ Sci-Fi"}
    
    embed = discord.Embed(
        title="ğŸ¬ FILMOVÃ KVÃZ ZAÄŒÃNÃ!",
        description=f"**{total_rounds} otÃ¡zek** | **{quiz_time}s na odpovÄ›Ä**",
        color=discord.Color.red()
    )
    embed.add_field(name="ğŸï¸ Å½Ã¡nr", value=genre_names.get(zanr, "NÃHODNÃ"), inline=True)
    embed.add_field(name="ğŸ“ Pravidla", value="NapiÅ¡ nÃ¡zev filmu do chatu!", inline=False)
    embed.set_footer(text="PrvnÃ­ otÃ¡zka za 3 sekundy...")
    
    await ctx.send(embed=embed)
    await asyncio.sleep(3)
    
    await run_film_quiz(ctx.channel, channel_id)

@bot.tree.command(name="stop", description="Zastav bÄ›Å¾Ã­cÃ­ kvÃ­z")
async def slash_stop(interaction: discord.Interaction):
    channel_id = interaction.channel_id
    stopped = []
    
    if channel_id in active_music_quiz:
        del active_music_quiz[channel_id]
        stopped.append("ğŸµ HudebnÃ­ kvÃ­z")
    
    if channel_id in active_film_quiz:
        del active_film_quiz[channel_id]
        stopped.append("ğŸ¬ FilmovÃ½ kvÃ­z")
    
    if stopped:
        await interaction.response.send_message(f"ğŸ›‘ Zastaveno: {', '.join(stopped)}")
    else:
        await interaction.response.send_message("âŒ Å½Ã¡dnÃ½ kvÃ­z nebÄ›Å¾Ã­ v tomto kanÃ¡lu.", ephemeral=True)

@bot.command(name="stop", aliases=["stophudba", "stopfilm"])
async def prefix_stop_quiz(ctx):
    """!stop - Zastav bÄ›Å¾Ã­cÃ­ kvÃ­z"""
    channel_id = ctx.channel.id
    stopped = []
    
    if channel_id in active_music_quiz:
        del active_music_quiz[channel_id]
        stopped.append("ğŸµ HudebnÃ­ kvÃ­z")
    
    if channel_id in active_film_quiz:
        del active_film_quiz[channel_id]
        stopped.append("ğŸ¬ FilmovÃ½ kvÃ­z")
    
    if stopped:
        await ctx.send(f"ğŸ›‘ Zastaveno: {', '.join(stopped)}")
    else:
        await ctx.send("âŒ Å½Ã¡dnÃ½ kvÃ­z nebÄ›Å¾Ã­ v tomto kanÃ¡lu.")

# Listen for quiz answers
@bot.event
async def on_message(message):
    if message.author.bot:
        return
    
    # SledovÃ¡nÃ­ zprÃ¡v pro statistiky
    if message.guild:
        increment_message_count(message.guild.id, message.author.id, message.author.display_name)
    
    # Skip if message is a command
    if message.content.startswith('!'):
        await bot.process_commands(message)
        return
    
    channel_id = message.channel.id
    
    # Check for active FILM quiz
    if channel_id in active_film_quiz:
        quiz_data = active_film_quiz[channel_id]
        
        if quiz_data.get("active") and quiz_data.get("current_question") and not quiz_data.get("answered"):
            user_answer = normalize_answer(message.content)
            correct_film = normalize_answer(quiz_data["current_question"]["film"])
            
            # Check if answer matches
            if len(user_answer) >= 3 and (correct_film in user_answer or user_answer in correct_film):
                quiz_data["answered"] = True
                
                # Add score
                user_id = message.author.id
                if user_id not in quiz_data["scores"]:
                    quiz_data["scores"][user_id] = {"name": message.author.display_name, "score": 0}
                quiz_data["scores"][user_id]["score"] += 1
                
                current_score = quiz_data["scores"][user_id]["score"]
                
                # Add XP
                guild_id = quiz_data.get("guild_id", message.guild.id)
                await add_xp(guild_id, user_id, message.author.display_name, XP_REWARDS["quiz_correct"], message.channel)
                increment_stats(guild_id, user_id, correct=True)
                
                embed = discord.Embed(
                    title="ğŸ‰ SPRÃVNÄš!",
                    description=f"**{message.author.display_name}** uhodl/a!",
                    color=discord.Color.green()
                )
                embed.add_field(name="ğŸ¬ Film", value=quiz_data["current_question"]["film"], inline=True)
                embed.add_field(name="ğŸ“… Rok", value=quiz_data["current_question"]["year"], inline=True)
                embed.add_field(name="ğŸ“Š SkÃ³re", value=f"{current_score} bodÅ¯", inline=True)
                embed.add_field(name="âœ¨ XP", value=f"+{XP_REWARDS['quiz_correct']} XP", inline=True)
                embed.set_thumbnail(url=message.author.display_avatar.url)
                
                await message.channel.send(f"ğŸ† {message.author.mention}", embed=embed)
    
    # Check for active MUSIC quiz
    if channel_id in active_music_quiz:
        quiz_data = active_music_quiz[channel_id]
        
        if quiz_data.get("active") and quiz_data.get("current_question") and not quiz_data.get("answered"):
            user_answer = normalize_answer(message.content)
            correct_artist = normalize_answer(quiz_data["current_question"]["artist"])
            
            # Check if answer matches
            if len(user_answer) >= 3 and (correct_artist in user_answer or user_answer in correct_artist):
                quiz_data["answered"] = True
                
                # Add score
                user_id = message.author.id
                if user_id not in quiz_data["scores"]:
                    quiz_data["scores"][user_id] = {"name": message.author.display_name, "score": 0}
                quiz_data["scores"][user_id]["score"] += 1
                
                current_score = quiz_data["scores"][user_id]["score"]
                
                # Add XP
                guild_id = quiz_data.get("guild_id", message.guild.id)
                await add_xp(guild_id, user_id, message.author.display_name, XP_REWARDS["quiz_correct"], message.channel)
                increment_stats(guild_id, user_id, correct=True)
                
                embed = discord.Embed(
                    title="ğŸ‰ SPRÃVNÄš!",
                    description=f"**{message.author.display_name}** uhodl/a!",
                    color=discord.Color.green()
                )
                embed.add_field(name="ğŸ¤ Interpret", value=quiz_data["current_question"]["artist"], inline=True)
                embed.add_field(name="ğŸµ PÃ­seÅˆ", value=quiz_data["current_question"]["song"], inline=True)
                embed.add_field(name="ğŸ“Š SkÃ³re", value=f"{current_score} bodÅ¯", inline=True)
                embed.add_field(name="âœ¨ XP", value=f"+{XP_REWARDS['quiz_correct']} XP", inline=True)
                embed.set_thumbnail(url=message.author.display_avatar.url)
                
                await message.channel.send(f"ğŸ† {message.author.mention}", embed=embed)
    
    await bot.process_commands(message)

# ============== RUN BOT ==============

if __name__ == "__main__":
    import sys
    sys.stdout.reconfigure(line_buffering=True)
    sys.stderr.reconfigure(line_buffering=True)
    
    token = os.environ.get('DISCORD_BOT_TOKEN')
    if not token:
        print("âŒ DISCORD_BOT_TOKEN nenÃ­ nastaven!", flush=True)
        exit(1)
    
    print("âš”ï¸ SpouÅ¡tÃ­m Valhalla Bot...", flush=True)
    bot.run(token)
