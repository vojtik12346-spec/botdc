#!/usr/bin/env python3
"""
Valhalla Bot - Discord kvÃ­zy a XP systÃ©m
"""

import discord
from discord.ext import commands
from discord import app_commands
import asyncio
import re
import os
import subprocess
import shutil
from datetime import datetime, timezone, timedelta
from dotenv import load_dotenv
import uuid
import math

# Auto-install FFmpeg if not present
def ensure_ffmpeg():
    """Ensure FFmpeg is installed"""
    if not shutil.which('ffmpeg'):
        print("âš ï¸ FFmpeg not found, installing...", flush=True)
        try:
            subprocess.run(['apt-get', 'update'], check=True, capture_output=True)
            subprocess.run(['apt-get', 'install', '-y', 'ffmpeg'], check=True, capture_output=True)
            print("âœ… FFmpeg installed successfully!", flush=True)
        except Exception as e:
            print(f"âŒ Failed to install FFmpeg: {e}", flush=True)
    else:
        print("âœ… FFmpeg is available", flush=True)

ensure_ffmpeg()

load_dotenv()

# MongoDB setup for XP system
from pymongo import MongoClient

mongo_url = os.environ.get("MONGO_URL", "mongodb://localhost:27017")
db_name = os.environ.get("DB_NAME", "quiz_bot")
mongo_client = MongoClient(mongo_url)
db = mongo_client[db_name]
users_collection = db["game_users"]
server_stats_collection = db["server_stats"]  # Pro statistiky serveru

# Bot setup
intents = discord.Intents.default()
intents.message_content = True
intents.presences = True  # Pro sledovÃ¡nÃ­ her
intents.members = True    # Pro sledovÃ¡nÃ­ ÄlenÅ¯
intents.voice_states = True  # Pro sledovÃ¡nÃ­ voice aktivity

bot = commands.Bot(command_prefix='!', intents=intents)

# ============== GAME TRACKING SYSTEM ==============

# BonusovÃ© hry - pÅ™i prvnÃ­m hranÃ­ dostane hrÃ¡Ä +25 XP bonus
BONUS_GAMES = {
    # PopulÃ¡rnÃ­ hry
    "Counter-Strike 2": {"emoji": "ğŸ¯", "category": "FPS"},
    "Minecraft": {"emoji": "â›ï¸", "category": "Sandbox"},
    "Fortnite": {"emoji": "ğŸï¸", "category": "Battle Royale"},
    "League of Legends": {"emoji": "âš”ï¸", "category": "MOBA"},
    "VALORANT": {"emoji": "ğŸ”«", "category": "FPS"},
    "Apex Legends": {"emoji": "ğŸ¦Š", "category": "Battle Royale"},
    "Rocket League": {"emoji": "ğŸš—", "category": "Sport"},
    "GTA V": {"emoji": "ğŸš”", "category": "Akce"},
    "Grand Theft Auto V": {"emoji": "ğŸš”", "category": "Akce"},
    "Roblox": {"emoji": "ğŸ§±", "category": "Sandbox"},
    "Overwatch 2": {"emoji": "ğŸ¦¸", "category": "FPS"},
    "Dota 2": {"emoji": "ğŸ—¡ï¸", "category": "MOBA"},
    "Call of Duty": {"emoji": "ğŸ’£", "category": "FPS"},
    "Warzone": {"emoji": "ğŸ’£", "category": "Battle Royale"},
    "FIFA 24": {"emoji": "âš½", "category": "Sport"},
    "EA SPORTS FC 24": {"emoji": "âš½", "category": "Sport"},
    "Destiny 2": {"emoji": "ğŸŒŒ", "category": "MMO"},
    "World of Warcraft": {"emoji": "ğŸ‰", "category": "MMO"},
    "Diablo IV": {"emoji": "ğŸ˜ˆ", "category": "RPG"},
    "Path of Exile": {"emoji": "âš¡", "category": "RPG"},
    "Elden Ring": {"emoji": "ğŸ—¡ï¸", "category": "RPG"},
    "Hogwarts Legacy": {"emoji": "ğŸ§™", "category": "RPG"},
    "Cyberpunk 2077": {"emoji": "ğŸ¤–", "category": "RPG"},
    "The Witcher 3": {"emoji": "ğŸº", "category": "RPG"},
    "Baldur's Gate 3": {"emoji": "ğŸ²", "category": "RPG"},
    "Terraria": {"emoji": "ğŸŒ³", "category": "Sandbox"},
    "Stardew Valley": {"emoji": "ğŸŒ¾", "category": "Simulace"},
    "Among Us": {"emoji": "ğŸš€", "category": "Party"},
    "Phasmophobia": {"emoji": "ğŸ‘»", "category": "Horor"},
    "Dead by Daylight": {"emoji": "ğŸ”ª", "category": "Horor"},
    "Rust": {"emoji": "ğŸšï¸", "category": "Survival"},
    "ARK: Survival Evolved": {"emoji": "ğŸ¦–", "category": "Survival"},
    "Sea of Thieves": {"emoji": "ğŸ´â€â˜ ï¸", "category": "DobrodruÅ¾stvÃ­"},
    "Euro Truck Simulator 2": {"emoji": "ğŸš›", "category": "Simulace"},
    "Cities: Skylines": {"emoji": "ğŸ™ï¸", "category": "Simulace"},
    "The Sims 4": {"emoji": "ğŸ ", "category": "Simulace"},
    "Spotify": {"emoji": "ğŸµ", "category": "Hudba"},
    "YouTube": {"emoji": "ğŸ“º", "category": "Video"},
    "Visual Studio Code": {"emoji": "ğŸ’»", "category": "KÃ³dovÃ¡nÃ­"},
    "Escape from Tarkov": {"emoji": "ğŸ’", "category": "FPS"},
    "Rainbow Six Siege": {"emoji": "ğŸ›¡ï¸", "category": "FPS"},
    "Lethal Company": {"emoji": "ğŸ’€", "category": "Horor"},
    "Palworld": {"emoji": "ğŸ¾", "category": "Survival"},
    "Helldivers 2": {"emoji": "ğŸª–", "category": "Akce"},
    "FiveM": {"emoji": "ğŸš”", "category": "RP"},
}

# Ãškoly pro kaÅ¾dou hru - {minuty: {"name": nÃ¡zev, "xp": odmÄ›na}}
GAME_QUESTS = {
    # KaÅ¾dÃ¡ hra mÃ¡ stejnÃ© zÃ¡kladnÃ­ Ãºkoly podle Äasu hranÃ­
    "default": [
        {"minutes": 60, "name": "NovÃ¡Äek", "xp": 50, "emoji": "ğŸŒŸ"},
        {"minutes": 180, "name": "HrÃ¡Ä", "xp": 100, "emoji": "â­"},
        {"minutes": 300, "name": "VeterÃ¡n", "xp": 150, "emoji": "ğŸ…"},
        {"minutes": 600, "name": "Expert", "xp": 250, "emoji": "ğŸ–ï¸"},
        {"minutes": 1200, "name": "Mistr", "xp": 400, "emoji": "ğŸ‘‘"},
        {"minutes": 3000, "name": "Legenda", "xp": 750, "emoji": "ğŸ†"},
        {"minutes": 6000, "name": "BÅ¯h", "xp": 1500, "emoji": "âš¡"},
    ],
    # SpeciÃ¡lnÃ­ Ãºkoly pro konkrÃ©tnÃ­ hry
    "Counter-Strike 2": [
        {"minutes": 60, "name": "PrvnÃ­ mise", "xp": 50, "emoji": "ğŸ¯"},
        {"minutes": 180, "name": "StÅ™elec", "xp": 100, "emoji": "ğŸ”«"},
        {"minutes": 300, "name": "Taktik", "xp": 150, "emoji": "ğŸ—ºï¸"},
        {"minutes": 600, "name": "Elite", "xp": 250, "emoji": "ğŸ’"},
        {"minutes": 1200, "name": "Global Elite", "xp": 400, "emoji": "ğŸŒ"},
        {"minutes": 3000, "name": "CS VeterÃ¡n", "xp": 750, "emoji": "ğŸ–ï¸"},
        {"minutes": 6000, "name": "CS Legenda", "xp": 1500, "emoji": "ğŸ‘‘"},
    ],
    "Minecraft": [
        {"minutes": 60, "name": "KopÃ¡Ä", "xp": 50, "emoji": "â›ï¸"},
        {"minutes": 180, "name": "Stavitel", "xp": 100, "emoji": "ğŸ "},
        {"minutes": 300, "name": "PrÅ¯zkumnÃ­k", "xp": 150, "emoji": "ğŸ—ºï¸"},
        {"minutes": 600, "name": "DraÄÃ­ lovec", "xp": 250, "emoji": "ğŸ‰"},
        {"minutes": 1200, "name": "Mistr stavitel", "xp": 400, "emoji": "ğŸ°"},
        {"minutes": 3000, "name": "Minecraft VeterÃ¡n", "xp": 750, "emoji": "ğŸ’"},
        {"minutes": 6000, "name": "Minecraft BÅ¯h", "xp": 1500, "emoji": "âš¡"},
    ],
    "League of Legends": [
        {"minutes": 60, "name": "Summoner", "xp": 50, "emoji": "âš”ï¸"},
        {"minutes": 180, "name": "Ranked Warrior", "xp": 100, "emoji": "ğŸ›¡ï¸"},
        {"minutes": 300, "name": "Diamant", "xp": 150, "emoji": "ğŸ’"},
        {"minutes": 600, "name": "Master", "xp": 250, "emoji": "ğŸ…"},
        {"minutes": 1200, "name": "Grandmaster", "xp": 400, "emoji": "ğŸ‘‘"},
        {"minutes": 3000, "name": "Challenger", "xp": 750, "emoji": "ğŸ†"},
        {"minutes": 6000, "name": "LoL Legenda", "xp": 1500, "emoji": "âš¡"},
    ],
    "Fortnite": [
        {"minutes": 60, "name": "PÅ™istÃ¡nÃ­", "xp": 50, "emoji": "ğŸª‚"},
        {"minutes": 180, "name": "PÅ™eÅ¾ivÅ¡Ã­", "xp": 100, "emoji": "ğŸï¸"},
        {"minutes": 300, "name": "Stavitel", "xp": 150, "emoji": "ğŸ—ï¸"},
        {"minutes": 600, "name": "Victory Royale", "xp": 250, "emoji": "ğŸ†"},
        {"minutes": 1200, "name": "Fortnite Pro", "xp": 400, "emoji": "ğŸ‘‘"},
        {"minutes": 3000, "name": "Fortnite VeterÃ¡n", "xp": 750, "emoji": "ğŸ–ï¸"},
        {"minutes": 6000, "name": "Fortnite Legenda", "xp": 1500, "emoji": "âš¡"},
    ],
    "VALORANT": [
        {"minutes": 60, "name": "Agent", "xp": 50, "emoji": "ğŸ”«"},
        {"minutes": 180, "name": "Taktik", "xp": 100, "emoji": "ğŸ¯"},
        {"minutes": 300, "name": "Radiant hrÃ¡Ä", "xp": 150, "emoji": "ğŸ’"},
        {"minutes": 600, "name": "Immortal", "xp": 250, "emoji": "ğŸ…"},
        {"minutes": 1200, "name": "Radiant", "xp": 400, "emoji": "ğŸ‘‘"},
        {"minutes": 3000, "name": "Valorant Pro", "xp": 750, "emoji": "ğŸ†"},
        {"minutes": 6000, "name": "Valorant Legenda", "xp": 1500, "emoji": "âš¡"},
    ],
    "GTA V": [
        {"minutes": 60, "name": "Gangster", "xp": 50, "emoji": "ğŸš—"},
        {"minutes": 180, "name": "ZloÄinec", "xp": 100, "emoji": "ğŸ’°"},
        {"minutes": 300, "name": "Å Ã©f gangu", "xp": 150, "emoji": "ğŸ”«"},
        {"minutes": 600, "name": "Kingpin", "xp": 250, "emoji": "ğŸ‘‘"},
        {"minutes": 1200, "name": "Los Santos Boss", "xp": 400, "emoji": "ğŸ†"},
        {"minutes": 3000, "name": "GTA VeterÃ¡n", "xp": 750, "emoji": "ğŸ–ï¸"},
        {"minutes": 6000, "name": "GTA Legenda", "xp": 1500, "emoji": "âš¡"},
    ],
    "Rocket League": [
        {"minutes": 60, "name": "Rookie", "xp": 50, "emoji": "ğŸš—"},
        {"minutes": 180, "name": "Pro", "xp": 100, "emoji": "âš½"},
        {"minutes": 300, "name": "Veteran", "xp": 150, "emoji": "ğŸ…"},
        {"minutes": 600, "name": "Champion", "xp": 250, "emoji": "ğŸ†"},
        {"minutes": 1200, "name": "Grand Champion", "xp": 400, "emoji": "ğŸ‘‘"},
        {"minutes": 3000, "name": "Supersonic", "xp": 750, "emoji": "ğŸš€"},
        {"minutes": 6000, "name": "RL Legenda", "xp": 1500, "emoji": "âš¡"},
    ],
}

# Game XP settings
GAME_XP_PER_10_MIN = 5
GAME_XP_DAILY_LIMIT = 200
GAME_UNLOCK_BONUS = 25
GAME_NOTIFICATION_CHANNEL = 1468355022159872073  # KanÃ¡l pro hernÃ­ notifikace
GAME_PING_ROLE = 485172457544744972  # Role pro ping pÅ™i splnÄ›nÃ­

# Track active gaming sessions {user_id: {"game": name, "start": datetime, "guild_id": id}}
active_gaming_sessions = {}

# Collection pro persistentnÃ­ hernÃ­ sessions
game_sessions_collection = db["game_sessions"]

def save_game_session(user_id: int, guild_id: int, game: str, user_name: str):
    """UloÅ¾ hernÃ­ session do databÃ¡ze"""
    game_sessions_collection.update_one(
        {"user_id": user_id},
        {"$set": {
            "user_id": user_id,
            "guild_id": guild_id,
            "game": game,
            "user_name": user_name,
            "start": datetime.now(timezone.utc)
        }},
        upsert=True
    )

def get_game_session(user_id: int) -> dict:
    """NaÄti hernÃ­ session z databÃ¡ze"""
    return game_sessions_collection.find_one({"user_id": user_id})

def delete_game_session(user_id: int):
    """SmaÅ¾ hernÃ­ session z databÃ¡ze"""
    game_sessions_collection.delete_one({"user_id": user_id})

# Collection pro nastavenÃ­ serveru
guild_settings_collection = db["guild_bot_settings"]

def get_guild_settings(guild_id: int) -> dict:
    """ZÃ­skej nastavenÃ­ pro server z databÃ¡ze"""
    settings = guild_settings_collection.find_one({"guild_id": str(guild_id)})
    if not settings:
        # VÃ½chozÃ­ nastavenÃ­
        return {
            "cmdHudba": True,
            "cmdFilm": True,
            "cmdPravda": True,
            "cmdGamelevel": False,
            "cmdTop": False,
            "cmdDaily": False,
            "cmdHry": False,
            "cmdUkoly": False,
            "cmdHerniinfo": True
        }
    return settings

def is_command_admin_only(guild_id: int, command_name: str) -> bool:
    """Zkontroluj zda pÅ™Ã­kaz vyÅ¾aduje admin oprÃ¡vnÄ›nÃ­"""
    settings = get_guild_settings(guild_id)
    key = f"cmd{command_name.capitalize()}"
    return settings.get(key, False)

async def check_command_permission(interaction: discord.Interaction, command_name: str) -> bool:
    """Zkontroluj oprÃ¡vnÄ›nÃ­ pro pÅ™Ã­kaz. VrÃ¡tÃ­ True pokud mÅ¯Å¾e pokraÄovat."""
    if is_command_admin_only(interaction.guild_id, command_name):
        if not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message(
                "âŒ Tento pÅ™Ã­kaz mÅ¯Å¾e pouÅ¾Ã­t pouze administrÃ¡tor!",
                ephemeral=True
            )
            return False
    return True

# ============== XP/LEVEL SYSTEM ==============

def calculate_level(xp: int) -> int:
    """Calculate level from XP (level = sqrt(xp/100))"""
    if xp <= 0:
        return 1
    return max(1, int(math.sqrt(xp / 100)) + 1)

def xp_for_level(level: int) -> int:
    """Calculate XP needed for a specific level"""
    if level <= 1:
        return 0
    return ((level - 1) ** 2) * 100

def get_user_data(guild_id: int, user_id: int) -> dict:
    """Get or create user data"""
    user = users_collection.find_one({"guild_id": guild_id, "user_id": user_id})
    if not user:
        user = {
            "guild_id": guild_id,
            "user_id": user_id,
            "xp": 0,
            "total_correct": 0,
            "total_games": 0,
            "streak": 0,
            "last_daily": None,
            "daily_game_xp": 0,
            "last_game_xp_reset": None,
            "unlocked_games": [],
            "completed_quests": {},  # {game_name: [completed_quest_indices]}
            "game_times": {},  # {game_name: minutes}
            "total_game_time": 0,  # v minutÃ¡ch
            "created_at": datetime.now(timezone.utc)
        }
        users_collection.insert_one(user)
    return user

def get_game_quests(game_name: str) -> list:
    """Get quests for a specific game"""
    if game_name in GAME_QUESTS:
        return GAME_QUESTS[game_name]
    return GAME_QUESTS["default"]

def get_game_time(guild_id: int, user_id: int, game_name: str) -> int:
    """Get total time played for a specific game"""
    user = get_user_data(guild_id, user_id)
    return user.get("game_times", {}).get(game_name, 0)

async def check_and_complete_quests(guild_id: int, user_id: int, user_name: str, game_name: str, total_minutes: int, channel=None):
    """Check if any quests are completed and give rewards"""
    user = get_user_data(guild_id, user_id)
    completed = user.get("completed_quests", {}).get(game_name, [])
    quests = get_game_quests(game_name)
    
    newly_completed = []
    total_xp = 0
    
    for i, quest in enumerate(quests):
        if i not in completed and total_minutes >= quest["minutes"]:
            newly_completed.append(i)
            total_xp += quest["xp"]
    
    if newly_completed:
        # Update completed quests
        users_collection.update_one(
            {"guild_id": guild_id, "user_id": user_id},
            {"$set": {f"completed_quests.{game_name}": completed + newly_completed}}
        )
        
        # Add XP
        await add_xp(guild_id, user_id, user_name, total_xp, None)
        
        # Send notification to game channel
        notify_channel = channel
        if not notify_channel:
            notify_channel = bot.get_channel(GAME_NOTIFICATION_CHANNEL)
        
        if notify_channel:
            for i in newly_completed:
                quest = quests[i]
                game_emoji = BONUS_GAMES.get(game_name, {}).get("emoji", "ğŸ®")
                
                embed = discord.Embed(
                    title=f"ğŸ¯ ÃšKOL SPLNÄšN!",
                    description=f"**{user_name}** splnil/a Ãºkol v **{game_name}**!",
                    color=discord.Color.gold()
                )
                embed.add_field(name=f"{quest['emoji']} Ãškol", value=quest["name"], inline=True)
                embed.add_field(name="âœ¨ OdmÄ›na", value=f"+{quest['xp']} XP", inline=True)
                embed.add_field(name="â±ï¸ ÄŒas", value=f"{total_minutes // 60}h {total_minutes % 60}m", inline=True)
                embed.set_footer(text="âš”ï¸ Valhalla Bot â€¢ PlÅˆ dalÅ¡Ã­ Ãºkoly a zÃ­skÃ¡vej XP!")
                await notify_channel.send(f"<@&{GAME_PING_ROLE}>", embed=embed)
    
    return total_xp

def get_daily_game_xp(guild_id: int, user_id: int) -> int:
    """Get how much game XP user earned today"""
    user = get_user_data(guild_id, user_id)
    last_reset = user.get("last_game_xp_reset")
    
    if last_reset:
        if isinstance(last_reset, str):
            last_reset = datetime.fromisoformat(last_reset.replace('Z', '+00:00'))
        
        # Reset if new day
        if (datetime.now(timezone.utc) - last_reset).days >= 1:
            users_collection.update_one(
                {"guild_id": guild_id, "user_id": user_id},
                {"$set": {"daily_game_xp": 0, "last_game_xp_reset": datetime.now(timezone.utc)}}
            )
            return 0
    
    return user.get("daily_game_xp", 0)

async def add_game_xp(guild_id: int, user_id: int, user_name: str, minutes: int, game_name: str = None, channel=None):
    """Add XP for gaming time"""
    # Calculate XP (5 XP per 10 minutes)
    xp_earned = (minutes // 10) * GAME_XP_PER_10_MIN
    
    if xp_earned <= 0:
        return 0
    
    # Check daily limit
    daily_xp = get_daily_game_xp(guild_id, user_id)
    remaining = GAME_XP_DAILY_LIMIT - daily_xp
    
    if remaining <= 0:
        return 0
    
    # Cap XP at remaining limit
    xp_earned = min(xp_earned, remaining)
    
    # Update daily game XP and game-specific time
    update_query = {
        "$inc": {"daily_game_xp": xp_earned, "total_game_time": minutes},
        "$set": {"last_game_xp_reset": datetime.now(timezone.utc)}
    }
    
    if game_name:
        update_query["$inc"][f"game_times.{game_name}"] = minutes
    
    users_collection.update_one(
        {"guild_id": guild_id, "user_id": user_id},
        update_query
    )
    
    # Add to total XP
    await add_xp(guild_id, user_id, user_name, xp_earned, channel)
    
    # Check for quest completion
    if game_name:
        user = get_user_data(guild_id, user_id)
        total_game_time = user.get("game_times", {}).get(game_name, 0) + minutes
        await check_and_complete_quests(guild_id, user_id, user_name, game_name, total_game_time, channel)
    
    return xp_earned

async def unlock_game(guild_id: int, user_id: int, user_name: str, game_name: str, channel=None) -> bool:
    """Unlock a bonus game and give bonus XP. Returns True if newly unlocked."""
    user = get_user_data(guild_id, user_id)
    unlocked = user.get("unlocked_games", [])
    
    if game_name in unlocked:
        return False
    
    # Unlock the game
    users_collection.update_one(
        {"guild_id": guild_id, "user_id": user_id},
        {"$push": {"unlocked_games": game_name}}
    )
    
    # Give bonus XP
    await add_xp(guild_id, user_id, user_name, GAME_UNLOCK_BONUS, None)
    
    # Send notification with role ping - VÅ½DY do sprÃ¡vnÃ©ho kanÃ¡lu
    notify_channel = bot.get_channel(GAME_NOTIFICATION_CHANNEL)
    if notify_channel and game_name in BONUS_GAMES:
        game_info = BONUS_GAMES[game_name]
        embed = discord.Embed(
            title="ğŸ® HRA ODEMÄŒENA!",
            description=f"**{user_name}** odemkl/a hru **{game_name}**!",
            color=discord.Color.purple()
        )
        embed.add_field(name="ğŸ·ï¸ Kategorie", value=game_info["category"], inline=True)
        embed.add_field(name="âœ¨ Bonus", value=f"+{GAME_UNLOCK_BONUS} XP", inline=True)
        embed.set_footer(text="Hraj vÃ­ce her a odemykej achievementy!")
        await notify_channel.send(f"<@&{GAME_PING_ROLE}>", embed=embed)
    
    return True

async def add_xp(guild_id: int, user_id: int, user_name: str, xp_amount: int, channel=None) -> bool:
    """Add XP to user and check for level up. Returns True if leveled up."""
    user = get_user_data(guild_id, user_id)
    old_level = calculate_level(user["xp"])
    new_xp = user["xp"] + xp_amount
    new_level = calculate_level(new_xp)
    
    users_collection.update_one(
        {"guild_id": guild_id, "user_id": user_id},
        {"$set": {"xp": new_xp, "name": user_name}}
    )
    
    # Level up notification - vÅ¾dy do sprÃ¡vnÃ©ho kanÃ¡lu
    if new_level > old_level:
        notify_channel = bot.get_channel(GAME_NOTIFICATION_CHANNEL)
        if notify_channel:
            embed = discord.Embed(
                title="ğŸ‰ LEVEL UP!",
                description=f"**{user_name}** dosÃ¡hl/a **Level {new_level}**!",
                color=discord.Color.gold()
            )
            embed.add_field(name="âœ¨ XP", value=f"{new_xp} XP", inline=True)
            embed.add_field(name="ğŸ“ˆ DalÅ¡Ã­ level", value=f"{xp_for_level(new_level + 1)} XP", inline=True)
            await notify_channel.send(embed=embed)
        return True
    return False

def increment_stats(guild_id: int, user_id: int, correct: bool = False):
    """Increment user game statistics"""
    update = {"$inc": {"total_games": 1}}
    if correct:
        update["$inc"]["total_correct"] = 1
    users_collection.update_one(
        {"guild_id": guild_id, "user_id": user_id},
        update
    )

# XP rewards
XP_REWARDS = {
    "quiz_correct": 25,      # SprÃ¡vnÃ¡ odpovÄ›Ä v kvÃ­zu
    "quiz_win": 50,          # VÃ½hra v kvÃ­zu (nejvÃ­c bodÅ¯)
    "truth_correct": 15,     # SprÃ¡vnÃ¡ odpovÄ›Ä pravda/leÅ¾
    "daily": 100,            # DennÃ­ bonus
    "streak_bonus": 10,      # Bonus za streak (per den)
}

# ============== COUNTDOWN FUNCTIONS ==============

def parse_time(time_str: str) -> int:
    """Parse time string like 2m, 5m, 1h into seconds"""
    time_str = time_str.lower().strip()
    
    pattern = r'^(\d+)([smhd])$'
    match = re.match(pattern, time_str)
    
    if not match:
        return None
    
    value = int(match.group(1))
    unit = match.group(2)
    
    multipliers = {
        's': 1,
        'm': 60,
        'h': 3600,
        'd': 86400
    }
    
    return value * multipliers[unit]

def format_time(seconds: int) -> str:
    """Format seconds into readable string"""
    if seconds <= 0:
        return "0s"
    
    days = seconds // 86400
    hours = (seconds % 86400) // 3600
    minutes = (seconds % 3600) // 60
    secs = seconds % 60
    
    parts = []
    if days > 0:
        parts.append(f"{days}d")
    if hours > 0:
        parts.append(f"{hours}h")
    if minutes > 0:
        parts.append(f"{minutes}m")
    if secs > 0 or not parts:
        parts.append(f"{secs}s")
    
    return " ".join(parts)

# Auto-delete helper
async def delete_after(message, seconds: int = 60):
    """Delete message after specified seconds (default 1 min)"""
    await asyncio.sleep(seconds)
    try:
        await message.delete()
    except:
        pass

# Store active countdowns
active_countdowns = {}

class CountdownView(discord.ui.View):
    def __init__(self, countdown_id: str, user_id: int):
        super().__init__(timeout=None)
        self.countdown_id = countdown_id
        self.user_id = user_id
    
    @discord.ui.button(label="ZruÅ¡it", style=discord.ButtonStyle.danger, emoji="âŒ")
    async def cancel_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id and not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message("âŒ Pouze autor nebo admin mÅ¯Å¾e zruÅ¡it odpoÄet!", ephemeral=True)
            return
        
        if self.countdown_id in active_countdowns:
            active_countdowns[self.countdown_id]["cancelled"] = True
            del active_countdowns[self.countdown_id]
        
        button.disabled = True
        button.label = "ZruÅ¡eno"
        
        embed = discord.Embed(
            title="âŒ OdpoÄet zruÅ¡en!",
            description=f"OdpoÄet byl zruÅ¡en uÅ¾ivatelem {interaction.user.mention}",
            color=discord.Color.red()
        )
        
        await interaction.response.edit_message(embed=embed, view=self)
        self.stop()

async def run_countdown(channel, message, end_time: int, countdown_id: str, author: discord.Member, reason: str):
    """Run the countdown and update message"""
    
    while True:
        if countdown_id not in active_countdowns:
            return
        
        if active_countdowns[countdown_id].get("cancelled"):
            return
        
        remaining = end_time - int(datetime.now(timezone.utc).timestamp())
        
        if remaining <= 0:
            break
        
        embed = discord.Embed(
            title="â° ODPOÄŒET",
            description=f"**{reason}**" if reason else "OdpoÄet bÄ›Å¾Ã­...",
            color=discord.Color.blue()
        )
        embed.add_field(name="â³ ZbÃ½vÃ¡", value=f"**{format_time(remaining)}**", inline=True)
        embed.add_field(name="ğŸ‘¤ Spustil", value=author.mention, inline=True)
        embed.set_footer(text=f"KonÄÃ­: {datetime.fromtimestamp(end_time).strftime('%H:%M:%S')}")
        
        try:
            await message.edit(embed=embed)
        except:
            pass
        
        if remaining > 3600:
            await asyncio.sleep(60)
        elif remaining > 60:
            await asyncio.sleep(10)
        else:
            await asyncio.sleep(1)
    
    # Countdown finished!
    if countdown_id in active_countdowns:
        del active_countdowns[countdown_id]
    
    embed = discord.Embed(
        title="ğŸ‰ ODPOÄŒET SKONÄŒIL!",
        description=f"**{reason}**" if reason else "ÄŒas vyprÅ¡el!",
        color=discord.Color.green()
    )
    embed.add_field(name="ğŸ‘¤ Spustil", value=author.mention, inline=True)
    
    view = discord.ui.View()
    disabled_btn = discord.ui.Button(label="DokonÄeno", style=discord.ButtonStyle.success, disabled=True, emoji="âœ…")
    view.add_item(disabled_btn)
    
    try:
        await message.edit(embed=embed, view=view)
    except:
        pass
    
    # Ping notification
    await channel.send(f"ğŸ”” **ODPOÄŒET SKONÄŒIL!** {author.mention}\n{'ğŸ“¢ ' + reason if reason else ''}")

# ============== EVENTS ==============

@bot.event
async def on_ready():
    print(f'ğŸ¤– Bot {bot.user} je online!', flush=True)
    print(f'ğŸ“Š PÅ™ipojen k {len(bot.guilds)} serverÅ¯m', flush=True)
    
    # NaÄti aktivnÃ­ hernÃ­ sessions z databÃ¡ze
    stored_sessions = list(game_sessions_collection.find({}))
    for session in stored_sessions:
        user_id = session.get("user_id")
        if user_id:
            active_gaming_sessions[user_id] = {
                "game": session.get("game"),
                "start": session.get("start"),
                "guild_id": session.get("guild_id"),
                "user_name": session.get("user_name")
            }
    print(f'ğŸ® NaÄteno {len(stored_sessions)} aktivnÃ­ch hernÃ­ch sessions', flush=True)
    
    # UloÅ¾it statistiky bota do databÃ¡ze
    users_collection.database.bot_stats.update_one(
        {"type": "global"},
        {"$set": {
            "guild_count": len(bot.guilds),
            "bot_name": str(bot.user),
            "updated_at": datetime.now(timezone.utc).isoformat()
        }},
        upsert=True
    )
    
    # UloÅ¾it seznam serverÅ¯
    for guild in bot.guilds:
        users_collection.database.bot_guilds.update_one(
            {"id": str(guild.id)},
            {"$set": {
                "id": str(guild.id),
                "name": guild.name,
                "icon": str(guild.icon.url) if guild.icon else None,
                "memberCount": guild.member_count,
                "updated_at": datetime.now(timezone.utc).isoformat()
            }},
            upsert=True
        )
    
    try:
        synced = await bot.tree.sync()
        print(f'âœ… SynchronizovÃ¡no {len(synced)} slash pÅ™Ã­kazÅ¯', flush=True)
    except Exception as e:
        print(f'âŒ Chyba pÅ™i synchronizaci: {e}', flush=True)

# ============== SERVER STATS SYSTEM ==============

# Voice tracking - kdo kdy vstoupil do voice
voice_sessions = {}  # {user_id: {"join_time": datetime, "channel_id": int, "guild_id": int}}

def get_server_stats(guild_id: int) -> dict:
    """ZÃ­skej nebo vytvoÅ™ statistiky serveru"""
    stats = server_stats_collection.find_one({"guild_id": guild_id})
    if not stats:
        stats = {
            "guild_id": guild_id,
            "total_messages": 0,
            "total_voice_minutes": 0,
            "user_messages": {},  # {user_id: count}
            "user_voice": {},     # {user_id: minutes}
            "daily_messages": 0,
            "daily_voice": 0,
            "last_reset": datetime.now(timezone.utc).isoformat()
        }
        server_stats_collection.insert_one(stats)
    return stats

def increment_message_count(guild_id: int, user_id: int, user_name: str):
    """PÅ™idej zprÃ¡vu do statistik"""
    today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    server_stats_collection.update_one(
        {"guild_id": guild_id},
        {
            "$inc": {
                "total_messages": 1,
                "daily_messages": 1,
                f"user_messages.{user_id}": 1,
                f"daily_user_messages.{today}.{user_id}": 1
            },
            "$set": {
                f"user_names.{user_id}": user_name
            }
        },
        upsert=True
    )

def add_voice_time(guild_id: int, user_id: int, user_name: str, minutes: int):
    """PÅ™idej voice Äas do statistik"""
    today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    server_stats_collection.update_one(
        {"guild_id": guild_id},
        {
            "$inc": {
                "total_voice_minutes": minutes,
                "daily_voice": minutes,
                f"user_voice.{user_id}": minutes,
                f"daily_user_voice.{today}.{user_id}": minutes
            },
            "$set": {
                f"user_names.{user_id}": user_name
            }
        },
        upsert=True
    )

@bot.event
async def on_voice_state_update(member, before, after):
    """SledovÃ¡nÃ­ voice aktivity"""
    if member.bot:
        return
    
    user_id = member.id
    guild_id = member.guild.id
    
    # UÅ¾ivatel vstoupil do voice kanÃ¡lu
    if before.channel is None and after.channel is not None:
        voice_sessions[user_id] = {
            "join_time": datetime.now(timezone.utc),
            "channel_id": after.channel.id,
            "guild_id": guild_id
        }
        print(f"[VOICE] {member.display_name} vstoupil do {after.channel.name}", flush=True)
    
    # UÅ¾ivatel opustil voice kanÃ¡l
    elif before.channel is not None and after.channel is None:
        if user_id in voice_sessions:
            session = voice_sessions[user_id]
            duration = datetime.now(timezone.utc) - session["join_time"]
            minutes = int(duration.total_seconds() / 60)
            
            if minutes > 0:
                add_voice_time(guild_id, user_id, member.display_name, minutes)
                print(f"[VOICE] {member.display_name} byl ve voice {minutes} minut", flush=True)
            
            del voice_sessions[user_id]
    
    # UÅ¾ivatel pÅ™eÅ¡el do jinÃ©ho kanÃ¡lu
    elif before.channel != after.channel:
        if user_id in voice_sessions:
            session = voice_sessions[user_id]
            duration = datetime.now(timezone.utc) - session["join_time"]
            minutes = int(duration.total_seconds() / 60)
            
            if minutes > 0:
                add_voice_time(guild_id, user_id, member.display_name, minutes)
            
            voice_sessions[user_id] = {
                "join_time": datetime.now(timezone.utc),
                "channel_id": after.channel.id,
                "guild_id": guild_id
            }

class ServerStatsView(discord.ui.View):
    def __init__(self, guild_id: int, period: int = 1):
        super().__init__(timeout=300)
        self.guild_id = guild_id
        self.period = period  # 1, 7, 30 dnÅ¯
    
    @discord.ui.button(label="1 den", style=discord.ButtonStyle.secondary, custom_id="stats_1d", emoji="ğŸ“Š")
    async def stats_1d(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.period = 1
        await self.update_stats(interaction)
    
    @discord.ui.button(label="7 dnÃ­", style=discord.ButtonStyle.secondary, custom_id="stats_7d", emoji="ğŸ“ˆ")
    async def stats_7d(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.period = 7
        await self.update_stats(interaction)
    
    @discord.ui.button(label="30 dnÃ­", style=discord.ButtonStyle.secondary, custom_id="stats_30d", emoji="ğŸ“‰")
    async def stats_30d(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.period = 30
        await self.update_stats(interaction)
    
    @discord.ui.button(label="Obnovit", style=discord.ButtonStyle.primary, custom_id="stats_refresh", emoji="ğŸ”„")
    async def stats_refresh(self, interaction: discord.Interaction, button: discord.ui.Button):
        await self.update_stats(interaction)
    
    async def update_stats(self, interaction: discord.Interaction):
        embed = await create_stats_embed(interaction.guild, self.period)
        
        # Update button styles
        for child in self.children:
            if isinstance(child, discord.ui.Button):
                if child.custom_id == f"stats_{self.period}d":
                    child.style = discord.ButtonStyle.success
                elif child.custom_id != "stats_refresh":
                    child.style = discord.ButtonStyle.secondary
        
        await interaction.response.edit_message(embed=embed, view=self)

async def create_stats_embed(guild, period: int = 1) -> discord.Embed:
    """VytvoÅ™Ã­ embed se statistikami"""
    stats = get_server_stats(guild.id)
    
    # ZÃ¡kladnÃ­ statistiky
    total_members = guild.member_count
    online_members = sum(1 for m in guild.members if m.status != discord.Status.offline)
    total_messages = stats.get("total_messages", 0)
    total_voice = stats.get("total_voice_minutes", 0)
    daily_messages = stats.get("daily_messages", 0)
    daily_voice = stats.get("daily_voice", 0)
    
    # ObdobÃ­ text
    period_text = f"PoslednÃ­ch {period} {'den' if period == 1 else 'dnÃ­'}"
    
    # FormÃ¡tovÃ¡nÃ­ voice Äasu
    voice_hours = total_voice // 60
    voice_mins = total_voice % 60
    daily_voice_hours = daily_voice // 60
    daily_voice_mins = daily_voice % 60
    
    # Top 5 pisatelÅ¯
    user_messages = stats.get("user_messages", {})
    user_names = stats.get("user_names", {})
    sorted_messages = sorted(user_messages.items(), key=lambda x: x[1], reverse=True)[:5]
    
    # Top 5 voice aktivita
    user_voice = stats.get("user_voice", {})
    sorted_voice = sorted(user_voice.items(), key=lambda x: x[1], reverse=True)[:5]
    
    # VytvoÅ™ embed
    embed = discord.Embed(
        title=f"ğŸ“Š Server Lookback: {period_text}",
        description=f"**{guild.name}**",
        color=discord.Color.blue()
    )
    
    if guild.icon:
        embed.set_thumbnail(url=guild.icon.url)
    
    # ZÃ¡kladnÃ­ stats
    embed.add_field(
        name="ğŸ‘¥ ÄŒlenovÃ©",
        value=f"```\n{total_members} celkem\n{online_members} online\n```",
        inline=True
    )
    embed.add_field(
        name="ğŸ’¬ ZprÃ¡vy",
        value=f"```\n{total_messages:,} celkem\n{daily_messages:,} dnes\n```",
        inline=True
    )
    embed.add_field(
        name="ğŸ¤ Voice",
        value=f"```\n{voice_hours}h {voice_mins}m celkem\n{daily_voice_hours}h {daily_voice_mins}m dnes\n```",
        inline=True
    )
    
    # Top pisatelÃ©
    if sorted_messages:
        top_writers = []
        medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰", "4.", "5."]
        for i, (uid, count) in enumerate(sorted_messages):
            name = user_names.get(uid, f"User {uid}")[:15]
            top_writers.append(f"{medals[i]} **{name}**: {count:,}")
        embed.add_field(
            name="âœï¸ TOP PisatelÃ©",
            value="\n".join(top_writers),
            inline=True
        )
    
    # Top voice
    if sorted_voice:
        top_voice = []
        medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰", "4.", "5."]
        for i, (uid, mins) in enumerate(sorted_voice):
            name = user_names.get(uid, f"User {uid}")[:15]
            h = mins // 60
            m = mins % 60
            time_str = f"{h}h {m}m" if h > 0 else f"{m}m"
            top_voice.append(f"{medals[i]} **{name}**: {time_str}")
        embed.add_field(
            name="ğŸ¤ TOP Voice",
            value="\n".join(top_voice),
            inline=True
        )
    
    # AktivnÃ­ ve voice prÃ¡vÄ› teÄ
    voice_now = sum(1 for vc in guild.voice_channels for m in vc.members if not m.bot)
    embed.add_field(
        name="ğŸ”Š PrÃ¡vÄ› ve voice",
        value=f"**{voice_now}** ÄlenÅ¯",
        inline=True
    )
    
    embed.set_footer(text=f"âš”ï¸ Valhalla Bot â€¢ AktualizovÃ¡no: {datetime.now().strftime('%H:%M:%S')}")
    
    return embed

@bot.tree.command(name="serverstats", description="Zobraz statistiky serveru (jen admin)")
@app_commands.checks.has_permissions(administrator=True)
async def server_stats_command(interaction: discord.Interaction):
    """ZobrazÃ­ statistiky serveru s interaktivnÃ­mi tlaÄÃ­tky"""
    embed = await create_stats_embed(interaction.guild, 1)
    view = ServerStatsView(interaction.guild.id, 1)
    
    # Nastav prvnÃ­ tlaÄÃ­tko jako aktivnÃ­
    view.children[0].style = discord.ButtonStyle.success
    
    await interaction.response.send_message(embed=embed, view=view)

@server_stats_command.error
async def server_stats_error(interaction: discord.Interaction, error):
    if isinstance(error, app_commands.MissingPermissions):
        await interaction.response.send_message("âŒ Tento pÅ™Ã­kaz mÅ¯Å¾e pouÅ¾Ã­t pouze administrÃ¡tor!", ephemeral=True)

# ============== MUSIC SYSTEM ==============

import yt_dlp
import subprocess
import os
import aiohttp

# PoznÃ¡mka: YouTube je blokovanÃ½ na cloudovÃ½ch serverech
# Tento systÃ©m podporuje pÅ™Ã­mÃ© audio URL a nÄ›kterÃ© dalÅ¡Ã­ zdroje

YTDL_OPTIONS = {
    'format': 'bestaudio/best',
    'outtmpl': '/tmp/music_%(id)s.%(ext)s',
    'restrictfilenames': True,
    'noplaylist': True,
    'nocheckcertificate': True,
    'ignoreerrors': True,
    'quiet': True,
    'no_warnings': True,
    'default_search': 'ytsearch',
    'extract_flat': False,
}

FFMPEG_OPTIONS = {
    'options': '-vn',
}

FFMPEG_EXECUTABLE = '/usr/bin/ffmpeg'

# PÅ™eddefinovanÃ© radio streamy
RADIO_STREAMS = {
    # ÄŒeskÃ© stanice
    "evropa2": {"url": "https://playerservices.streamtheworld.com/api/livestream-redirect/EVROPA2.mp3", "name": "ğŸ‡¨ğŸ‡¿ Evropa 2", "category": "cz"},
    "frekvence1": {"url": "https://playerservices.streamtheworld.com/api/livestream-redirect/FREKVENCE1.mp3", "name": "ğŸ‡¨ğŸ‡¿ Frekvence 1", "category": "cz"},
    "impuls": {"url": "https://playerservices.streamtheworld.com/api/livestream-redirect/IMPULS.mp3", "name": "ğŸ‡¨ğŸ‡¿ RÃ¡dio Impuls", "category": "cz"},
    "kiss": {"url": "https://playerservices.streamtheworld.com/api/livestream-redirect/KISS_CZAAC.aac", "name": "ğŸ‡¨ğŸ‡¿ Kiss RÃ¡dio", "category": "cz"},
    "blanik": {"url": "https://playerservices.streamtheworld.com/api/livestream-redirect/BLANIK.mp3", "name": "ğŸ‡¨ğŸ‡¿ RÃ¡dio BlanÃ­k", "category": "cz"},
    "beat": {"url": "https://playerservices.streamtheworld.com/api/livestream-redirect/BEAT.mp3", "name": "ğŸ‡¨ğŸ‡¿ Radio Beat", "category": "cz"},
    "country": {"url": "https://playerservices.streamtheworld.com/api/livestream-redirect/COUNTRY_RADIO.mp3", "name": "ğŸ‡¨ğŸ‡¿ Country Radio", "category": "cz"},
    "rockzone": {"url": "https://playerservices.streamtheworld.com/api/livestream-redirect/ROCKZONE_128.mp3", "name": "ğŸ‡¨ğŸ‡¿ Rock Zone", "category": "cz"},
    
    # Lo-Fi & Chill
    "lofi": {"url": "https://streams.ilovemusic.de/iloveradio17.mp3", "name": "ğŸ˜´ Lo-Fi Hip Hop", "category": "chill"},
    "chillout": {"url": "https://streams.ilovemusic.de/iloveradio7.mp3", "name": "ğŸŒ´ Chill Out", "category": "chill"},
    "sleep": {"url": "https://streams.ilovemusic.de/iloveradio18.mp3", "name": "ğŸ˜´ Sleep", "category": "chill"},
    "spa": {"url": "http://149.56.155.73:80/RELAXATION", "name": "ğŸ§˜ Spa & Relax", "category": "chill"},
    
    # Electronic & Dance
    "dance": {"url": "https://streams.ilovemusic.de/iloveradio2.mp3", "name": "ğŸ’ƒ Dance", "category": "electronic"},
    "techno": {"url": "https://streams.ilovemusic.de/iloveradio6.mp3", "name": "ğŸ›ï¸ Techno", "category": "electronic"},
    "trance": {"url": "http://trance.stream.laut.fm/trance", "name": "ğŸŒ€ Trance", "category": "electronic"},
    "house": {"url": "https://streams.ilovemusic.de/iloveradio23.mp3", "name": "ğŸ  House", "category": "electronic"},
    "edm": {"url": "https://streams.ilovemusic.de/iloveradio109.mp3", "name": "âš¡ EDM Hits", "category": "electronic"},
    "hardstyle": {"url": "https://streams.ilovemusic.de/iloveradio21.mp3", "name": "ğŸ’¥ Hardstyle", "category": "electronic"},
    
    # Rock & Metal
    "rock": {"url": "https://streams.ilovemusic.de/iloveradio16.mp3", "name": "ğŸ¸ Rock", "category": "rock"},
    "metal": {"url": "http://stream.laut.fm/metal", "name": "ğŸ¤˜ Metal", "category": "rock"},
    "classicrock": {"url": "https://streams.ilovemusic.de/iloveradio108.mp3", "name": "ğŸ¸ Classic Rock", "category": "rock"},
    
    # Hip Hop & Rap
    "hiphop": {"url": "https://streams.ilovemusic.de/iloveradio3.mp3", "name": "ğŸ¤ Hip Hop", "category": "hiphop"},
    "rap": {"url": "https://streams.ilovemusic.de/iloveradio13.mp3", "name": "ğŸ”¥ Rap", "category": "hiphop"},
    "oldschool": {"url": "https://streams.ilovemusic.de/iloveradio12.mp3", "name": "ğŸ“¼ Old School Rap", "category": "hiphop"},
    
    # Pop & Charts
    "top100": {"url": "https://streams.ilovemusic.de/iloveradio1.mp3", "name": "ğŸ“Š Top 100", "category": "pop"},
    "pop": {"url": "https://streams.ilovemusic.de/iloveradio14.mp3", "name": "ğŸµ Pop", "category": "pop"},
    "charts": {"url": "https://streams.ilovemusic.de/iloveradio109.mp3", "name": "ğŸ“ˆ Charts", "category": "pop"},
    "2000s": {"url": "https://streams.ilovemusic.de/iloveradio4.mp3", "name": "ğŸ’¿ 2000s Hits", "category": "pop"},
    "90s": {"url": "https://streams.ilovemusic.de/iloveradio5.mp3", "name": "ğŸ’½ 90s Hits", "category": "pop"},
    "80s": {"url": "https://streams.ilovemusic.de/iloveradio8.mp3", "name": "ğŸ“» 80s Hits", "category": "pop"},
    
    # Other
    "jazz": {"url": "http://streaming.radio.co/s3c5f5e27a/listen", "name": "ğŸ· Jazz", "category": "other"},
    "classical": {"url": "http://149.56.155.73:80/CLASSIC", "name": "ğŸ» Classical", "category": "other"},
    "reggae": {"url": "http://stream.laut.fm/reggae", "name": "ğŸ‡¯ğŸ‡² Reggae", "category": "other"},
    "latina": {"url": "https://streams.ilovemusic.de/iloveradio24.mp3", "name": "ğŸ’ƒ Latino", "category": "other"},
}

ytdl = yt_dlp.YoutubeDL(YTDL_OPTIONS)

class YTDLSource(discord.PCMVolumeTransformer):
    def __init__(self, source, *, data, volume=0.5):
        super().__init__(source, volume)
        self.data = data
        self.title = data.get('title')
        self.url = data.get('url')
        self.duration = data.get('duration', 0)
        self.thumbnail = data.get('thumbnail')
        self.webpage_url = data.get('webpage_url')
        self.filename = data.get('filename')

    @classmethod
    async def from_url(cls, url, *, loop=None, stream=False):
        loop = loop or asyncio.get_event_loop()
        
        # StÃ¡hnout soubor mÃ­sto streamovÃ¡nÃ­ (kvÅ¯li 403)
        try:
            data = await loop.run_in_executor(None, lambda: ytdl.extract_info(url, download=True))
        except Exception as e:
            print(f"[MUSIC] Download error: {e}", flush=True)
            raise e

        if 'entries' in data:
            data = data['entries'][0]

        filename = ytdl.prepare_filename(data)
        data['filename'] = filename
        
        return cls(discord.FFmpegPCMAudio(filename, executable=FFMPEG_EXECUTABLE, **FFMPEG_OPTIONS), data=data)

# Music queues per guild
music_queues = {}  # {guild_id: {"queue": [], "current": None, "loop": False}}

def get_music_queue(guild_id: int) -> dict:
    if guild_id not in music_queues:
        music_queues[guild_id] = {"queue": [], "current": None, "loop": False, "volume": 0.5}
    return music_queues[guild_id]

def format_duration(seconds: int) -> str:
    if not seconds:
        return "NeznÃ¡mÃ¡ dÃ©lka"
    mins, secs = divmod(seconds, 60)
    hours, mins = divmod(mins, 60)
    if hours:
        return f"{hours}:{mins:02d}:{secs:02d}"
    return f"{mins}:{secs:02d}"

async def play_next(guild_id: int, voice_client):
    """PÅ™ehraje dalÅ¡Ã­ pÃ­sniÄku z fronty"""
    queue_data = get_music_queue(guild_id)
    
    if queue_data["loop"] and queue_data["current"]:
        # Opakovat aktuÃ¡lnÃ­
        try:
            source = await YTDLSource.from_url(queue_data["current"]["url"], stream=False)
            source.volume = queue_data["volume"]
            voice_client.play(source, after=lambda e: asyncio.run_coroutine_threadsafe(
                play_next(guild_id, voice_client), bot.loop))
        except Exception as e:
            print(f"[MUSIC] Error playing: {e}", flush=True)
        return
    
    if not queue_data["queue"]:
        queue_data["current"] = None
        return
    
    next_song = queue_data["queue"].pop(0)
    queue_data["current"] = next_song
    
    try:
        source = await YTDLSource.from_url(next_song["url"], stream=False)
        source.volume = queue_data["volume"]
        voice_client.play(source, after=lambda e: asyncio.run_coroutine_threadsafe(
            play_next(guild_id, voice_client), bot.loop))
        print(f"[MUSIC] Now playing: {next_song['title']}", flush=True)
    except Exception as e:
        print(f"[MUSIC] Error playing: {e}", flush=True)
        await play_next(guild_id, voice_client)

@bot.tree.command(name="radio", description="PÅ™ehraj rÃ¡dio stanici")
@app_commands.describe(stanice="Vyber rÃ¡dio stanici")
@app_commands.choices(stanice=[
    app_commands.Choice(name="ğŸ‡¨ğŸ‡¿ Evropa 2", value="evropa2"),
    app_commands.Choice(name="ğŸ‡¨ğŸ‡¿ Frekvence 1", value="frekvence1"),
    app_commands.Choice(name="ğŸ‡¨ğŸ‡¿ RÃ¡dio Impuls", value="impuls"),
    app_commands.Choice(name="ğŸ‡¨ğŸ‡¿ Kiss RÃ¡dio", value="kiss"),
    app_commands.Choice(name="ğŸ‡¨ğŸ‡¿ Rock Zone", value="rockzone"),
    app_commands.Choice(name="ğŸ˜´ Lo-Fi Hip Hop", value="lofi"),
    app_commands.Choice(name="ğŸŒ´ Chill Out", value="chillout"),
    app_commands.Choice(name="ğŸ’ƒ Dance", value="dance"),
    app_commands.Choice(name="ğŸ›ï¸ Techno", value="techno"),
    app_commands.Choice(name="ğŸ¸ Rock", value="rock"),
    app_commands.Choice(name="ğŸ¤ Hip Hop", value="hiphop"),
    app_commands.Choice(name="ğŸ“Š Top 100", value="top100"),
])
async def radio_command(interaction: discord.Interaction, stanice: str):
    """PÅ™ehraje ÄeskÃ© rÃ¡dio"""
    if not interaction.user.voice:
        await interaction.response.send_message("âŒ MusÃ­Å¡ bÃ½t ve voice kanÃ¡lu!", ephemeral=True)
        return
    
    if stanice not in RADIO_STREAMS:
        await interaction.response.send_message("âŒ NeznÃ¡mÃ¡ stanice!", ephemeral=True)
        return
    
    radio = RADIO_STREAMS[stanice]
    voice_channel = interaction.user.voice.channel
    voice_client = interaction.guild.voice_client
    
    # PÅ™ipojit se k voice
    if not voice_client:
        voice_client = await voice_channel.connect()
    elif voice_client.channel != voice_channel:
        await voice_client.move_to(voice_channel)
    
    # Zastavit aktuÃ¡lnÃ­ pÅ™ehrÃ¡vÃ¡nÃ­
    if voice_client.is_playing():
        voice_client.stop()
    
    queue_data = get_music_queue(interaction.guild_id)
    queue_data["current"] = {"title": radio["name"], "url": radio["url"], "duration": 0, "requester": interaction.user.display_name}
    
    try:
        source = discord.FFmpegPCMAudio(radio["url"], executable=FFMPEG_EXECUTABLE, **FFMPEG_OPTIONS)
        source = discord.PCMVolumeTransformer(source, volume=queue_data["volume"])
        voice_client.play(source)
        
        embed = discord.Embed(
            title="ğŸ“» RÃ¡dio hraje",
            description=f"**{radio['name']}**",
            color=discord.Color.red()
        )
        embed.add_field(name="ğŸ§ PoÅ¾Ã¡dal", value=interaction.user.display_name, inline=True)
        embed.add_field(name="ğŸ“¡ Typ", value="Å½ivÃ© vysÃ­lÃ¡nÃ­", inline=True)
        embed.set_footer(text="âš”ï¸ Valhalla Bot â€¢ /musicstop pro zastavenÃ­")
        
        await interaction.response.send_message(embed=embed)
    except Exception as e:
        await interaction.response.send_message(f"âŒ Chyba: {e}", ephemeral=True)

@bot.tree.command(name="radiolist", description="Zobraz vÅ¡echny dostupnÃ© rÃ¡dio stanice")
async def radiolist_command(interaction: discord.Interaction):
    """ZobrazÃ­ seznam vÅ¡ech rÃ¡diÃ­ podle kategorie"""
    embed = discord.Embed(
        title="ğŸ“» DostupnÃ© rÃ¡dio stanice",
        description="PouÅ¾ij `/radio [stanice]` pro pÅ™ehrÃ¡nÃ­",
        color=discord.Color.blue()
    )
    
    categories = {
        "cz": "ğŸ‡¨ğŸ‡¿ ÄŒeskÃ© stanice",
        "chill": "ğŸ˜´ Chill & Lo-Fi",
        "electronic": "âš¡ Electronic & Dance",
        "rock": "ğŸ¸ Rock & Metal",
        "hiphop": "ğŸ¤ Hip Hop & Rap",
        "pop": "ğŸµ Pop & Charts",
        "other": "ğŸ· OstatnÃ­"
    }
    
    for cat_key, cat_name in categories.items():
        stations = [f"`{k}` - {v['name']}" for k, v in RADIO_STREAMS.items() if v.get('category') == cat_key]
        if stations:
            embed.add_field(name=cat_name, value="\n".join(stations[:6]), inline=True)
    
    embed.set_footer(text="âš”ï¸ Valhalla Bot â€¢ Celkem 35+ stanic")
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="play", description="PÅ™ehraj hudbu (URL streamu nebo rÃ¡dio)")
@app_commands.describe(url="PÅ™Ã­mÃ½ URL na audio stream")
async def play_command(interaction: discord.Interaction, url: str):
    """PÅ™ehraje audio z pÅ™Ã­mÃ©ho URL"""
    if not interaction.user.voice:
        await interaction.response.send_message("âŒ MusÃ­Å¡ bÃ½t ve voice kanÃ¡lu!", ephemeral=True)
        return
    
    await interaction.response.defer()
    
    voice_channel = interaction.user.voice.channel
    voice_client = interaction.guild.voice_client
    
    # PÅ™ipojit se k voice
    if not voice_client:
        voice_client = await voi